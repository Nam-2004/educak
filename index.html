<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ôn Thi Big Data Nâng Cao</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e2e8f0; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .quiz-container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 16px; /* More rounded corners */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15); /* Stronger shadow */
            max-width: 900px; /* Wider container */
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 25px; /* Increased spacing */
            border: 1px solid #cbd5e1; /* Subtle border */
        }
        .header-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 15px;
        }
        .timer-progress-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 15px 20px;
            background-color: #ebf8ff; /* Lighter blue */
            border-radius: 12px;
            border: 1px solid #90cdf4;
            color: #2b6cb0; /* Darker blue text */
            font-weight: 600;
        }
        .timer-display {
            font-size: 1.6rem; /* Larger timer font */
            text-align: center;
            color: #2d3748; /* Dark gray */
        }
        .timer-controls {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 8px;
        }
        .timer-controls button {
            padding: 10px 20px;
            border-radius: 8px;
            background-color: #4299e1; /* Blue */
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .timer-controls button:hover {
            background-color: #3182ce;
            transform: translateY(-1px);
        }
        .timer-controls button:disabled {
            background-color: #a0aec0; /* Gray disabled */
            cursor: not-allowed;
            box-shadow: none;
        }
        .progress-bar-container {
            width: 100%;
            height: 12px; /* Thicker progress bar */
            background-color: #e2e8f0;
            border-radius: 6px;
            overflow: hidden;
        }
        .progress-bar-fill {
            height: 100%;
            width: 0%;
            background-color: #667eea; /* Indigo */
            border-radius: 6px;
            transition: width 0.3s ease-out;
        }

        .settings-toggles {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 15px 20px;
            background-color: #f7fafc; /* Lighter gray */
            border-radius: 12px;
            border: 1px solid #e2e8f0;
        }
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .toggle-switch input[type="checkbox"] {
            position: relative;
            width: 48px; /* Larger toggle */
            height: 28px;
            -webkit-appearance: none;
            background: #cbd5e1; /* Gray */
            outline: none;
            border-radius: 24px;
            box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.1);
            transition: 0.3s;
            cursor: pointer;
        }
        .toggle-switch input[type="checkbox"]:checked {
            background: #667eea; /* Indigo */
        }
        .toggle-switch input[type="checkbox"]::before {
            content: '';
            position: absolute;
            width: 20px; /* Larger handle */
            height: 20px;
            border-radius: 50%;
            background: #fff;
            top: 4px;
            left: 4px;
            transition: 0.3s;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }
        .toggle-switch input[type="checkbox"]:checked::before {
            left: 24px;
        }
        .toggle-switch label {
            font-size: 1.05rem;
            color: #4a5568;
            font-weight: 500;
        }

        .question-nav {
            display: flex;
            flex-wrap: wrap;
            gap: 10px; /* Increased gap */
            margin-bottom: 25px;
            justify-content: center;
            padding: 10px;
            background-color: #f7fafc;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            max-height: 150px; /* Limit height */
            overflow-y: auto; /* Scrollable */
        }
        .question-nav-button {
            padding: 10px 15px; /* Larger buttons */
            border-radius: 10px; /* More rounded */
            background-color: #e0e7ff;
            color: #5a67d8; /* Indigo text */
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s, box-shadow 0.2s;
            border: 1px solid #c3dafe;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }
        .question-nav-button:hover {
            background-color: #c7d2fe;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .question-nav-button.active {
            background-color: #667eea; /* Active indigo */
            color: #ffffff;
            border-color: #667eea;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            transform: translateY(-1px);
        }
        .question-nav-button.answered-correctly {
            background-color: #c6f6d5; /* Light green */
            color: #2f855a;
            border-color: #68d391;
        }
        .question-nav-button.answered-incorrectly {
            background-color: #fed7d7; /* Light red */
            color: #c53030;
            border-color: #fc8181;
        }
        .question-nav-button.marked-for-review {
            background-color: #feebc8; /* Light orange */
            color: #d69e2e;
            border-color: #fbd38d;
        }


        .question-box {
            background-color: #f7fafc;
            padding: 30px;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
        }
        .question-text {
            font-size: 1.4rem; /* Larger question text */
            font-weight: 700;
            margin-bottom: 25px;
            color: #2d3748; /* Dark gray */
            line-height: 1.6;
        }
        .options-grid {
            display: grid;
            gap: 15px; /* Increased gap */
        }
        .option-button {
            width: 100%;
            padding: 15px 20px; /* Larger padding */
            border-radius: 10px;
            border: 2px solid #cbd5e1;
            background-color: #ffffff;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-size: 1.1rem; /* Larger option font */
            color: #4a5568;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }
        .option-button:hover:not(.selected):not(.correct):not(.incorrect):not(.disabled) {
            background-color: #ebf8ff; /* Light blue on hover */
            border-color: #90cdf4;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .option-button.selected {
            background-color: #bee3f8; /* Blue selected */
            border-color: #63b3ed;
            font-weight: 600;
            color: #2c5282;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }
        .option-button.correct {
            background-color: #c6f6d5; /* Green correct */
            border-color: #68d391;
            font-weight: 600;
            color: #2f855a;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }
        .option-button.incorrect {
            background-color: #fed7d7; /* Red incorrect */
            border-color: #fc8181;
            font-weight: 600;
            color: #c53030;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }
        .option-button.disabled {
            cursor: not-allowed;
            opacity: 0.8; /* Slightly less opaque */
            box-shadow: none;
        }
        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 25px;
            gap: 15px;
        }
        .nav-button {
            padding: 14px 28px; /* Larger buttons */
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            flex-grow: 1; /* Make buttons grow */
            text-align: center;
        }
        .nav-button.prev {
            background-color: #718096; /* Gray */
            color: #ffffff;
        }
        .nav-button.prev:hover {
            background-color: #4a5568;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
        .nav-button.next, .nav-button.check, .nav-button.mark-for-review, .nav-button.reset-quiz {
            background-color: #667eea; /* Indigo */
            color: #ffffff;
        }
        .nav-button.next:hover, .nav-button.check:hover, .nav-button.mark-for-review:hover, .nav-button.reset-quiz:hover {
            background-color: #5a67d8;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
        .nav-button:disabled {
            background-color: #cbd5e1;
            color: #a0aec0;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        .score-display {
            font-size: 1.25rem;
            font-weight: 700;
            color: #2d3748;
            text-align: center;
            margin-top: 20px;
            padding: 15px;
            background-color: #e0f2fe;
            border-radius: 12px;
            border: 1px solid #90cdf4;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none;
            flex-direction: column;
            gap: 20px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            border: 1px solid #cbd5e1;
        }
        .message-box-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 999;
            display: none;
        }
        .message-box-title {
            font-size: 1.8rem;
            font-weight: bold;
            color: #2d3748;
        }
        .message-box-content {
            font-size: 1.1rem;
            color: #4a5568;
        }
        .message-box-button {
            padding: 12px 25px;
            background-color: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .message-box-button:hover {
            background-color: #5a67d8;
            transform: translateY(-1px);
        }

        .quiz-summary {
            background-color: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            margin-top: 25px;
            display: none;
            border: 1px solid #e2e8f0;
        }
        .quiz-summary h2 {
            font-size: 2rem;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 25px;
            text-align: center;
        }
        .incorrect-question-item, .marked-question-item {
            background-color: #fff5f5; /* Lighter red */
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #fed7d7;
            margin-bottom: 20px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.05);
        }
        .marked-question-item {
            background-color: #fffaf0; /* Lighter orange */
            border-color: #feebc8;
        }
        .incorrect-question-item p, .marked-question-item p {
            margin-bottom: 10px;
            line-height: 1.6;
        }
        .incorrect-question-item .question-text-summary, .marked-question-item .question-text-summary {
            font-weight: 700;
            color: #c53030;
            font-size: 1.1rem;
        }
        .marked-question-item .question-text-summary {
            color: #d69e2e;
        }
        .incorrect-question-item .correct-answer-summary, .marked-question-item .correct-answer-summary {
            font-weight: 700;
            color: #38a169; /* Green for correct answer text */
            font-size: 1.05rem;
        }
        .incorrect-question-item .hint-summary, .marked-question-item .hint-summary {
            font-style: italic;
            color: #718096;
            font-size: 0.95rem;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px dashed #e2e8f0;
        }
        .summary-section-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #2d3748;
            margin-top: 30px;
            margin-bottom: 20px;
            padding-bottom: 8px;
            border-bottom: 2px solid #cbd5e1;
            text-align: left;
        }
        .no-items-message {
            text-align: center;
            color: #718096;
            font-style: italic;
            padding: 10px 0;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .quiz-container {
                padding: 20px;
                gap: 20px;
            }
            .header-section {
                gap: 15px;
            }
            .timer-progress-section, .settings-toggles {
                padding: 12px 15px;
                gap: 10px;
            }
            .timer-display {
                font-size: 1.4rem;
            }
            .timer-controls button {
                padding: 8px 15px;
                font-size: 0.9rem;
            }
            .toggle-switch label {
                font-size: 0.95rem;
            }
            .question-nav {
                gap: 8px;
                margin-bottom: 20px;
            }
            .question-nav-button {
                padding: 8px 12px;
                font-size: 0.9rem;
            }
            .question-text {
                font-size: 1.2rem;
                margin-bottom: 20px;
            }
            .options-grid {
                gap: 12px;
            }
            .option-button {
                padding: 12px 15px;
                font-size: 1rem;
            }
            .navigation-buttons {
                flex-wrap: wrap;
                justify-content: center;
                gap: 10px;
            }
            .nav-button {
                flex-basis: 48%; /* Two buttons per row */
                padding: 12px 20px;
                font-size: 0.95rem;
            }
            .score-display {
                font-size: 1.1rem;
                padding: 12px;
            }
            .quiz-summary {
                padding: 20px;
            }
            .quiz-summary h2 {
                font-size: 1.75rem;
            }
            .incorrect-question-item, .marked-question-item {
                padding: 15px;
            }
            .incorrect-question-item .question-text-summary, .marked-question-item .question-text-summary {
                font-size: 1rem;
            }
            .summary-section-title {
                font-size: 1.3rem;
            }
        }

        @media (max-width: 480px) {
            .quiz-container {
                padding: 15px;
            }
            .timer-display {
                font-size: 1.2rem;
            }
            .timer-controls {
                flex-direction: column;
                gap: 8px;
            }
            .timer-controls button {
                width: 100%;
            }
            .nav-button {
                flex-basis: 100%; /* One button per row */
            }
            .question-nav {
                max-height: 120px;
            }
        }
    </style>
</head>
<body>
    <div class="quiz-container">
        <h1 class="text-3xl font-bold text-center text-indigo-700 mb-6">Ôn Thi Big Data Nâng Cao</h1>

        <div class="header-section">
            <div class="timer-progress-section">
                <div class="flex items-center justify-between">
                    <label for="timeLimitInput" class="text-gray-700 font-medium mr-2">Thời gian làm bài:</label>
                    <input type="number" id="timeLimitInput" value="60" min="1" max="180" class="w-24 p-2 border border-gray-300 rounded-md text-center text-base"> phút
                </div>
                <div id="timerDisplay" class="timer-display">00:00</div>
                <div class="timer-controls">
                    <button id="startTimerBtn">Bắt đầu</button>
                    <button id="pauseTimerBtn" disabled>Tạm dừng</button>
                    <button id="resetTimerBtn">Đặt lại</button>
                </div>
                <div class="progress-bar-container">
                    <div id="progressBarFill" class="progress-bar-fill"></div>
                </div>
            </div>

            <div class="settings-toggles">
                <div class="toggle-switch">
                    <input type="checkbox" id="shuffleQuestionsOrder" checked>
                    <label for="shuffleQuestionsOrder" class="text-gray-700 font-medium">Đảo thứ tự câu hỏi</label>
                </div>
                <div class="toggle-switch">
                    <input type="checkbox" id="shuffleAnswers" checked>
                    <label for="shuffleAnswers" class="text-gray-700 font-medium">Đảo thứ tự đáp án</label>
                </div>
                <div class="toggle-switch">
                    <input type="checkbox" id="studyModeToggle">
                    <label for="studyModeToggle" class="text-gray-700 font-medium">Chế độ học (Kiểm tra ngay)</label>
                </div>
            </div>
        </div>

        <div class="question-nav" id="questionNav">
            <!-- Các nút điều hướng câu hỏi sẽ được tạo tự động tại đây -->
        </div>

        <div class="question-box">
            <div id="questionNumber" class="text-lg font-semibold text-gray-600 mb-2"></div>
            <div id="questionText" class="question-text"></div>
            <div id="optionsContainer" class="options-grid">
                <!-- Các lựa chọn đáp án sẽ được tạo tự động tại đây -->
            </div>
        </div>

        <div class="navigation-buttons">
            <button id="prevBtn" class="nav-button prev">Câu trước (←)</button>
            <button id="markForReviewBtn" class="nav-button mark-for-review">Đánh dấu xem lại</button>
            <button id="checkAnswerBtn" class="nav-button check">Kiểm tra đáp án (Enter)</button>
            <button id="nextBtn" class="nav-button next">Câu tiếp theo (→)</button>
        </div>

        <div id="scoreDisplay" class="score-display hidden"></div>
        <button id="resetQuizBtn" class="nav-button reset-quiz mt-4 hidden">Làm lại bài thi</button>

        <!-- Quiz Summary Section -->
        <div id="quizSummary" class="quiz-summary hidden">
            <h2>Tổng kết bài thi</h2>
            <h3 class="summary-section-title">Các câu hỏi làm sai</h3>
            <div id="incorrectQuestionsList">
                <!-- Incorrect questions will be listed here -->
                <p class="no-items-message">Không có câu trả lời sai!</p>
            </div>
            <h3 class="summary-section-title">Các câu hỏi đã đánh dấu xem lại</h3>
            <div id="markedQuestionsList">
                <!-- Marked for review questions will be listed here -->
                <p class="no-items-message">Không có câu hỏi nào được đánh dấu để xem lại.</p>
            </div>
        </div>

        <!-- Message Box -->
        <div class="message-box-overlay" id="messageBoxOverlay"></div>
        <div class="message-box" id="messageBox">
            <div class="message-box-title" id="messageBoxTitle"></div>
            <div class="message-box-content" id="messageBoxContent"></div>
            <button class="message-box-button" id="messageBoxButton">Đóng</button>
        </div>

    </div>

    <script>
        // Dữ liệu câu hỏi được trích xuất từ file PDF về Big Data
        const quizData = [
            {
                question: "Dữ liệu của Big Data là loại nào ?",
                options: [
                    "Structured Data",
                    "Semi-Structured Data",
                    "Unstructured Data",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Big Data bao gồm cả dữ liệu có cấu trúc, bán cấu trúc và phi cấu trúc."
            },
            {
                question: "Đặc trưng nào không phải của Big Data",
                options: [
                    "Volume",
                    "Variety",
                    "Vision",
                    "Velocity"
                ],
                answer: "C",
                hint: "Các đặc trưng của Big Data thường được biết đến là 3Vs (Volume, Variety, Velocity), đôi khi mở rộng thành 5Vs (thêm Veracity, Value). Vision không phải là đặc trưng."
            },
            {
                question: "NoSQL là ?",
                options: [
                    "Database",
                    "Field",
                    "Document",
                    "Collection"
                ],
                answer: "A",
                hint: "NoSQL là một loại cơ sở dữ liệu (Database) không theo mô hình quan hệ truyền thống."
            },
            {
                question: "Mục tiêu của NoSQL là gì?",
                options: [
                    "NoSQL cung cấp một giải pháp thay thế cho cơ sở dữ liệu SQL để lưu trữ dữ liệu dạng văn bản.",
                    "Cơ sở dữ liệu NoSQL cho phép lưu trữ dữ liệu không có cấu trúc.",
                    "NoSQL không thích hợp để lưu trữ dữ liệu có cấu trúc.",
                    "NoSQL là một định dạng dữ liệu mới để lưu trữ các tập dữ liệu lớn."
                ],
                answer: "B",
                hint: "Mục tiêu chính của NoSQL là hỗ trợ lưu trữ và xử lý dữ liệu không có cấu trúc hoặc bán cấu trúc."
            },
            {
                question: "Cloudera phát triển công cụ nào ?",
                options: [
                    "HCatalog",
                    "Hbase",
                    "Imphala",
                    "Oozie"
                ],
                answer: "B",
                hint: "Cloudera là một trong những nhà phát triển chính của Apache HBase, một CSDL NoSQL phân tán."
            },
            {
                question: "Loại nào không phải là CSDL NoSQL ?",
                options: [
                    "SQL Server",
                    "MongoDB",
                    "Cassandra",
                    "Không có"
                ],
                answer: "A",
                hint: "SQL Server là một hệ quản trị cơ sở dữ liệu quan hệ (RDBMS), không phải NoSQL."
            },
            {
                question: "Đâu là một kiểu của CSDL NoSQL",
                options: [
                    "SQL",
                    "Document databases",
                    "JSON",
                    "Tất cả"
                ],
                answer: "B",
                hint: "Document databases (cơ sở dữ liệu tài liệu) là một trong các kiểu của NoSQL."
            },
            {
                question: "Chọn đúng 5 đặc trưng cho Big Data ?",
                options: [
                    "Volume, Velocity, Variety, Veracity, Value",
                    "Volume, Videos, Velocity, Variability, Value",
                    "Volume, Variability, Veracity, Visualization, Value",
                    "Volume, Velocity, Veracity, Visualization, Value"
                ],
                answer: "A",
                hint: "5Vs phổ biến của Big Data là Volume (khối lượng), Velocity (tốc độ), Variety (đa dạng), Veracity (tính xác thực) và Value (giá trị)."
            },
            {
                question: "Velocity (Tốc độ) là đặc trưng nói về?",
                options: [
                    "Tốc độ gia tăng khối lượng dữ liệu lớn",
                    "Tốc độ cập nhật dữ liệu lớn",
                    "Tốc độ xử lý dữ liệu lớn",
                    "Tốc độ lưu trữ dữ liệu lớn"
                ],
                answer: "A",
                hint: "Velocity trong Big Data đề cập đến tốc độ tạo ra, thu thập và xử lý dữ liệu."
            },
            {
                question: "Variety (Tính đa dạng) là đặc trưng về ?",
                options: [
                    "Kiêu dữ liệu thu thập",
                    "Kiểu nội dung dữ liệu",
                    "Nguồn thu thập dữ liệu",
                    "Phương thức xử lý dữ liệu"
                ],
                answer: "A",
                hint: "Variety đề cập đến các dạng và nguồn dữ liệu khác nhau (có cấu trúc, bán cấu trúc, phi cấu trúc)."
            },
            {
                question: "Đặc trưng quan trọng nhất của Big Data?",
                options: [
                    "Khối lượng",
                    "Tính đa dạng",
                    "Tốc độ",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Không có một đặc trưng nào là quan trọng nhất tuyệt đối; tất cả các đặc trưng (Volume, Variety, Velocity) đều quan trọng trong việc định nghĩa Big Data."
            },
            {
                question: "Đâu là đặc trưng quyết việc triển khai Dữ liệu lớn?",
                options: [
                    "Khối lượng",
                    "Giá trị",
                    "Tốc Độ",
                    "Tính đa dạng"
                ],
                answer: "B",
                hint: "Value (Giá trị) là đặc trưng quyết định việc triển khai Big Data vì mục tiêu cuối cùng là tạo ra giá trị từ dữ liệu."
            },
            {
                question: "Tích hợp dữ liệu là quá trình ?",
                options: [
                    "Kết hợp các dữ liệu không đồng nhất từ nhiều nguồn khác nhau",
                    "Sao chép dữ liệu vào CSDL hệ thống để tiến hành phân tích",
                    "Làm sạch các dữ liệu thu thập được từ các hệ thống thành phần",
                    "Tăng giá trị từ các tài nguyên dữ liệu đang lưu trữ phân tán"
                ],
                answer: "A",
                hint: "Tích hợp dữ liệu là việc kết hợp dữ liệu từ các nguồn khác nhau thành một cái nhìn thống nhất."
            },
            {
                question: "Thuật ngữ Dữ liệu lớn ra đời năm nào?",
                options: [
                    "1997",
                    "2000",
                    "1998",
                    "1941"
                ],
                answer: "A",
                hint: "Thuật ngữ 'Big Data' được đặt ra vào năm 1997 bởi John Mashey."
            },
            {
                question: "Các dạng thức khoa học dữ liệu của Jim Gray?",
                options: [
                    "Thực nghiệm",
                    "Lý thuyết",
                    "Tính toán",
                    "Tất cả các ý"
                ],
                answer: "D",
                hint: "Jim Gray đã mô tả bốn dạng thức khoa học: Thực nghiệm, Lý thuyết, Tính toán, và Dựa trên dữ liệu (Data-driven)."
            },
            {
                question: "Phát biểu nào không phải dạng thức nghiên cứu Khoa học dữ liệu của Jim Gray?",
                options: [
                    "Khai thác dữ liệu",
                    "Mô phỏng",
                    "Tính toán",
                    "Thực nghiệm"
                ],
                answer: "A",
                hint: "Khai thác dữ liệu là một kỹ thuật, không phải dạng thức nghiên cứu cơ bản theo Jim Gray."
            },
            {
                question: "Đâu không phải là phương thức xử lý dữ liệu lớn?",
                options: [
                    "Thu thập (acquire)",
                    "Đánh giá (reviews)",
                    "Tổ chức (organize)",
                    "Phân tích (analyze)"
                ],
                answer: "B",
                hint: "Các phương thức xử lý dữ liệu lớn bao gồm Thu thập, Tổ chức, Phân tích, nhưng 'Đánh giá' không phải là một giai đoạn xử lý chính."
            },
            {
                question: "RDBMS là gì ?",
                options: [
                    "Relational Database Management System",
                    "Relat Data Management System",
                    "Relational Database Microsoft System",
                    "Tất cả"
                ],
                answer: "A",
                hint: "RDBMS là viết tắt của Relational Database Management System (Hệ quản trị cơ sở dữ liệu quan hệ)."
            },
            {
                question: "Thị trường Big Data bao gồm:",
                options: [
                    "Phần cứng",
                    "Phần Mềm",
                    "Tất cả",
                    "Dịch vụ"
                ],
                answer: "C",
                hint: "Thị trường Big Data bao gồm Phần cứng, Phần mềm và Dịch vụ."
            },
            {
                question: "Nhược điểm của tích hợp dữ liệu theo phương pháp Tight Coupling",
                options: [
                    "Độ trễ",
                    "Phản hồi truy vấn",
                    "Phụ thuộc vào nguồn dữ liệu",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Tight Coupling (liên kết chặt) trong tích hợp dữ liệu có nhược điểm về độ trễ, phản hồi truy vấn và sự phụ thuộc vào nguồn dữ liệu."
            },
            {
                question: "Nhược điểm của tích hợp dữ liệu theo phương pháp Loose Coupling",
                options: [
                    "Tất cả",
                    "Chi phí cao",
                    "Độ trễ",
                    "Phụ thuộc mạng / băng thông"
                ],
                answer: "D",
                hint: "Loose Coupling (liên kết lỏng) có nhược điểm về sự phụ thuộc vào mạng/băng thông và có thể có độ trễ."
            },
            {
                question: "Công cụ nào hỗ trợ tốt NoSQL?",
                options: [
                    "SAP Data Services",
                    "Oracle Data Integrator",
                    "SQL Server Integration Services",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Các công cụ tích hợp dữ liệu hiện đại như SAP Data Services, Oracle Data Integrator, SQL Server Integration Services đều có khả năng hỗ trợ NoSQL."
            },
            {
                question: "Công cụ tích hợp dữ liệu Boomi là của?",
                options: [
                    "Dell",
                    "IBM",
                    "Microsoft",
                    "SAP"
                ],
                answer: "A",
                hint: "Dell Boomi là một nền tảng tích hợp dữ liệu thuộc sở hữu của Dell."
            },
            {
                question: "Công cụ SQL Server Integrator do ai phát triển ?",
                options: [
                    "Oracle",
                    "IBM",
                    "Microsoft",
                    "SAP"
                ],
                answer: "C",
                hint: "SQL Server Integration Services (SSIS) là một phần của Microsoft SQL Server."
            },
            {
                question: "SAP Data Service là công cụ để làm gì ?",
                options: [
                    "Lưu trữ dữ liệu",
                    "Tích hợp dữ liệu",
                    "Phân tích dữ liệu",
                    "Tất cả"
                ],
                answer: "B",
                hint: "SAP Data Services là một công cụ mạnh mẽ cho việc tích hợp dữ liệu (ETL)."
            },
            {
                question: "Hệ quản trị CSLD DynamoDB là kiểu nào ?",
                options: [
                    "Key value",
                    "Wide Column based",
                    "Document based",
                    "Graph based"
                ],
                answer: "A",
                hint: "Amazon DynamoDB là một cơ sở dữ liệu NoSQL kiểu Key-Value và Document."
            },
            {
                question: "Hệ quản trị CSLD MongoDB là kiểu nào ?",
                options: [
                    "Document based",
                    "Key value",
                    "Wide Column based",
                    "Graph based"
                ],
                answer: "A",
                hint: "MongoDB là cơ sở dữ liệu NoSQL phổ biến thuộc kiểu Document-based."
            },
            {
                question: "Hệ quản trị CSLD Neo4J là kiểu nào ?",
                options: [
                    "Key value",
                    "Wide Column based",
                    "Document based",
                    "Graph based"
                ],
                answer: "D",
                hint: "Neo4j là cơ sở dữ liệu NoSQL hàng đầu thuộc kiểu Graph-based (cơ sở dữ liệu đồ thị)."
            },
            {
                question: "Hệ quản trị CSLD IBM Graph là kiểu nào ?",
                options: [
                    "Key value",
                    "Document based",
                    "Graph based",
                    "Wide Column based"
                ],
                answer: "C",
                hint: "IBM Graph là một dịch vụ cơ sở dữ liệu đồ thị."
            },
            {
                question: "Hệ quản trị CSLD Google Big Table là kiểu nào ?",
                options: [
                    "Key value",
                    "Wide Column based",
                    "Document based",
                    "Graph based"
                ],
                answer: "B",
                hint: "Google Bigtable là cơ sở dữ liệu NoSQL kiểu Wide-Column Store."
            },
            {
                question: "Đâu không phải là RDBMS ?",
                options: [
                    "IBM DB2",
                    "MS SQL Server",
                    "MS Access",
                    "Cassandra"
                ],
                answer: "D",
                hint: "Cassandra là một cơ sở dữ liệu NoSQL (Wide-column store), không phải RDBMS."
            },
            {
                question: "Loại nào là dữ liệu Bán cấu trúc ?",
                options: [
                    "Tất cả",
                    "JSON",
                    "CSV",
                    "XML"
                ],
                answer: "A",
                hint: "JSON, CSV, XML đều là các định dạng dữ liệu bán cấu trúc."
            },
            {
                question: "Loại nào là dữ liệu Unstructured ?",
                options: [
                    "Video",
                    "XML",
                    "Table",
                    "Tất cả"
                ],
                answer: "A",
                hint: "Video là một ví dụ điển hình của dữ liệu phi cấu trúc."
            },
            {
                question: "Yếu tố nào quyết định để sử dụng NoSQL",
                options: [
                    "Tốc độ gia tăng CSDL",
                    "Tính đa dạng của dữ liệu",
                    "Tốc độ truy cập dữ liệu",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Tất cả các yếu tố (tốc độ gia tăng dữ liệu, tính đa dạng, tốc độ truy cập) đều ảnh hưởng đến quyết định sử dụng NoSQL."
            },
            {
                question: "CSDL nào không phải kiểu Key-Value:",
                options: [
                    "MongoDB",
                    "DynamoDB",
                    "Redis",
                    "Riak"
                ],
                answer: "A",
                hint: "MongoDB là cơ sở dữ liệu tài liệu (Document-based), không phải Key-Value."
            },
            {
                question: "CSDL nào không phải kiểu Document:",
                options: [
                    "MongoDB",
                    "CouchDB",
                    "Elasticsearch",
                    "Riak"
                ],
                answer: "D",
                hint: "Riak là cơ sở dữ liệu Key-Value, không phải Document-based."
            },
            {
                question: "CSDL nào không phải kiểu Graph:",
                options: [
                    "InfoGrid",
                    "Hbase",
                    "InfiniteGraph",
                    "IBM Graph"
                ],
                answer: "B",
                hint: "HBase là cơ sở dữ liệu Wide-column, không phải Graph."
            },
            {
                question: "CSDL nào không phải kiểu Wide-Column:",
                options: [
                    "Hbase",
                    "Cassandra",
                    "BigTable",
                    "Dex"
                ],
                answer: "D",
                hint: "Dex là một cơ sở dữ liệu đồ thị (Graph database), không phải Wide-column."
            },
            {
                question: "Ưu điểm của hệ thống HDFS là gì ?",
                options: [
                    "Lưu trữ phân tán, xử lý song song, khả năng chịu lỗi cao",
                    "Lưu trữ song song, xử lý phân tán, tính sẵn sàng cao",
                    "Xử lý phân tán song song, khả năng chịu lỗi chấp nhận sai sót",
                    "Tất cả"
                ],
                answer: "A",
                hint: "HDFS được thiết kế để lưu trữ phân tán, xử lý song song và có khả năng chịu lỗi."
            },
            {
                question: "Ưu điểm của DFS là gì ?",
                options: [
                    "Hệ thống lưu trữ song song nên tránh được ảnh hưởng khi một máy chủ hoặc bộ nhớ bị lỗi",
                    "Hệ thống được sao lưu tại Server thứ hai nên đảm bảo việc cung cấp dữ liệu",
                    "Khi một máy chủ hoặc bộ nhớ bị lỗi, hệ thống tệp phân tán vẫn đảm bảo có thể cung cấp dữ liệu ổn định",
                    "Tất cả"
                ],
                answer: "C",
                hint: "Ưu điểm chính của Hệ thống tệp phân tán (DFS) là khả năng chịu lỗi và cung cấp dữ liệu ổn định."
            },
            {
                question: "Ưu điểm của công nghệ Cluster",
                options: [
                    "Tất cả",
                    "Hiệu quả chi phí",
                    "Tính sẵn sàng cao",
                    "Khả năng mở rộng linh hoạt"
                ],
                answer: "A",
                hint: "Công nghệ Cluster mang lại hiệu quả chi phí, tính sẵn sàng cao và khả năng mở rộng linh hoạt."
            },
            {
                question: "Cluster node có mấy loại ?",
                options: [
                    "1",
                    "2",
                    "3",
                    "4"
                ],
                answer: "B",
                hint: "Trong kiến trúc Hadoop, có hai loại node chính là NameNode (Master) và DataNode (Slave)."
            },
            {
                question: "Nguồn của kiến trúc HDFS trong Hadoop có nguồn gốc là",
                options: [
                    "Hệ thống tệp phân phối của Google",
                    "Hệ thống tệp phân tán của Yahoo",
                    "Hệ thống tệp phân tán của Facebook",
                    "Hệ thống tệp phân tán Azure"
                ],
                answer: "A",
                hint: "HDFS được lấy cảm hứng từ Google File System (GFS)."
            },
            {
                question: "Loại dữ liệu mà Hadoop có thể xử lý là",
                options: [
                    "Structred (Có cấu trúc)",
                    "Semi-structured (Bán cấu trúc)",
                    "Unstructured (Không có cấu trúc)",
                    "All of the above (Tất cả những điều trên)"
                ],
                answer: "D",
                hint: "Hadoop có khả năng xử lý tất cả các loại dữ liệu: có cấu trúc, bán cấu trúc và phi cấu trúc."
            },
            {
                question: "YARN là viết tắt của",
                options: [
                    "Yahoo's another resource name",
                    "Yet another resource negotiator",
                    "Yahoo's archived Resource names",
                    "Yet another resource need."
                ],
                answer: "B",
                hint: "YARN là viết tắt của Yet Another Resource Negotiator."
            },
            {
                question: "Điều nào sau đây không phải là mục tiêu của HDFS?",
                options: [
                    "Phát hiện lỗi và khôi phục",
                    "Xử lý tập dữ liệu khổng lồ",
                    "Ngăn chặn việc xóa dữ liệu",
                    "Cung cấp băng thông mạng cao để di chuyển dữ liệu"
                ],
                answer: "C",
                hint: "HDFS không có mục tiêu 'Ngăn chặn việc xóa dữ liệu'. Nó tập trung vào khả năng chịu lỗi, xử lý dữ liệu lớn và băng thông cao."
            },
            {
                question: "Trong HDFS, các tệp không thể",
                options: [
                    "Đọc",
                    "Xóa",
                    "Thực thi",
                    "Lưu trữ"
                ],
                answer: "C",
                hint: "Trong HDFS, các tệp không thể trực tiếp 'Thực thi'."
            },
            {
                question: "So với RDBMS, Hadoop",
                options: [
                    "Có tính toàn vẹn dữ liệu cao hơn.",
                    "Có giao dịch ACID không",
                    "Thích hợp để đọc và truy vấn nhanh",
                    "Hoạt động tốt hơn trên dữ liệu phi cấu trúc và bán cấu trúc."
                ],
                answer: "D",
                hint: "Hadoop vượt trội trong việc xử lý dữ liệu phi cấu trúc và bán cấu trúc so với RDBMS."
            },
            {
                question: "Vấn đề chính gặp phải khi đọc và ghi dữ liệu song song từ nhiều đĩa là gì?",
                options: [
                    "Xử lý khối lượng lớn dữ liệu nhanh hơn.",
                    "Kết hợp dữ liệu từ nhiều đĩa.",
                    "Phần mềm cần thiết để thực hiện nhiệm vụ này là cực kỳ tốn kém.",
                    "Phần cứng cần thiết để thực hiện tác vụ này là cực kỳ tốn kém."
                ],
                answer: "B",
                hint: "Thách thức chính là kết hợp và đồng bộ hóa dữ liệu từ nhiều nguồn khác nhau."
            },
            {
                question: "Tính năng định vị dữ liệu trong Hadoop có nghĩa là",
                options: [
                    "lưu trữ cùng một dữ liệu trên nhiều nút.",
                    "chuyên vị trí dữ liệu từ nút này sang nút khác.",
                    "đồng định vị dữ liệu với các nút tính toán.",
                    "Phân phối dữ liệu trên nhiều nút."
                ],
                answer: "C",
                hint: "Data locality (định vị dữ liệu) trong Hadoop có nghĩa là chuyển quá trình tính toán đến nơi dữ liệu được lưu trữ."
            },
            {
                question: "Các tệp HDFS được thiết kế cho",
                options: [
                    "Nhiều người viết và sửa đổi ở các hiệu số tùy ý.",
                    "Chỉ nối vào cuối tệp.",
                    "Chỉ ghi thành tệp một lần.",
                    "Truy cập dữ liệu có độ trễ thấp."
                ],
                answer: "C",
                hint: "HDFS được tối ưu cho mô hình 'ghi một lần, đọc nhiều lần' (write-once, read-many)."
            },
            {
                question: "Hệ thống Apache Hadoop được viết bằng ngôn ngữ nào?",
                options: [
                    "C ++",
                    "Python",
                    "Java",
                    "Go"
                ],
                answer: "C",
                hint: "Apache Hadoop chủ yếu được viết bằng Java."
            },
            {
                question: "Cái nào không phải là một trong đặc trưng 3Vs của dữ liệu lớn?",
                options: [
                    "Vận tốc - Velocity",
                    "Tính xác thực - Veracity",
                    "Khối lượng - Volume",
                    "Đa dạng - Variety"
                ],
                answer: "B",
                hint: "Tính xác thực (Veracity) là một trong 5Vs, nhưng không phải là một trong 3Vs gốc."
            },
            {
                question: "Điều nào sau đây đúng đối với Hadoop?",
                options: [
                    "Đây là một khung phân tán.",
                    "Thuật toán chính được sử dụng trong đó là Map Reduce.",
                    "Nó chạy có thể thực thi trên hạ tầng Cloud Computing.",
                    "Tất cả đều đúng"
                ],
                answer: "D",
                hint: "Tất cả các phát biểu trên đều đúng về Hadoop."
            },
            {
                question: "Loại nào sau đây lưu trữ dữ liệu?",
                options: [
                    "Name node",
                    "Data node",
                    "Master node",
                    "Không có"
                ],
                answer: "B",
                hint: "DataNode là nơi lưu trữ dữ liệu thực tế trong HDFS."
            },
            {
                question: "Node nào sau đây quản lý các nút khác?",
                options: [
                    "Name node",
                    "Data node",
                    "Slave node",
                    "Tất cả"
                ],
                answer: "A",
                hint: "NameNode là Master node, quản lý không gian tên tệp và điều phối các DataNode."
            },
            {
                question: "Hadoop xử lý khối lượng lớn dữ liệu như thế nào?",
                options: [
                    "Hadoop sử dụng song song rất nhiều máy. Điều này tối ưu hóa việc xử lý dữ liệu.",
                    "Hadoop được thiết kế đặc biệt để xử lý lượng lớn dữ liệu bằng cách tận dụng phần cứng MPP.",
                    "Hadoop gửi mã đến dữ liệu thay vì gửi dữ liệu đến mã.",
                    "Hadoop sử dụng các kỹ thuật bộ nhớ đệm phức tạp trên NameNode để tăng tốc độ xử lý dữ liệu."
                ],
                answer: "C",
                hint: "Hadoop áp dụng nguyên tắc 'data locality': di chuyển logic xử lý (mã) đến gần dữ liệu thay vì di chuyển dữ liệu."
            },
            {
                question: "MapReduce do công ty nào phát triển ?",
                options: [
                    "Apache",
                    "Google",
                    "IBM",
                    "Amazon"
                ],
                answer: "B",
                hint: "MapReduce được phát triển bởi Google."
            },
            {
                question: "Dịch vụ đám mây nào hỗ trợ tốt cho Big Data ?",
                options: [
                    "Amazon AWS",
                    "Google Cloud",
                    "Tất cả",
                    "Microsoft Azure"
                ],
                answer: "C",
                hint: "Tất cả các nhà cung cấp đám mây lớn như AWS, Google Cloud, Azure đều có các dịch vụ hỗ trợ Big Data mạnh mẽ."
            },
            {
                question: "Nhược điểm khi triển khai Big Data trên nền tảng Cloud Computing là?",
                options: [
                    "Nhiều rủi ro cho hệ thống",
                    "Không có ý đúng",
                    "Tốc độ xử lý không đảm bảo",
                    "Phân tích theo thời gian thực kém"
                ],
                answer: "A",
                hint: "Triển khai trên đám mây có thể tiềm ẩn rủi ro về bảo mật và kiểm soát dữ liệu nếu không được quản lý đúng cách."
            },
            {
                question: "Mô hình Điện toán đám mây IaaS ?",
                options: [
                    "Cơ sở hạ tầng dưới dạng dịch vụ",
                    "Nền tảng dưới dạng dịch vụ",
                    "Phần mềm dưới dạng dịch vụ",
                    "Internet dưới dạng dịch vụ"
                ],
                answer: "A",
                hint: "IaaS là viết tắt của Infrastructure as a Service."
            },
            {
                question: "Mô hình Điện toán đám mây PaaS ?",
                options: [
                    "Cơ sở hạ tầng dưới dạng dịch vụ",
                    "Nền tảng dưới dạng dịch vụ",
                    "Phần mềm dưới dạng dịch vụ",
                    "Internet dưới dạng dịch vụ"
                ],
                answer: "B",
                hint: "PaaS là viết tắt của Platform as a Service."
            },
            {
                question: "Mô hình Điện toán đám mây SaaS ?",
                options: [
                    "Cơ sở hạ tầng dưới dạng dịch vụ",
                    "Nền tảng dưới dạng dịch vụ",
                    "Phần mềm dưới dạng dịch vụ",
                    "Internet dưới dạng dịch vụ"
                ],
                answer: "C",
                hint: "SaaS là viết tắt của Software as a Service."
            },
            {
                question: "Lợi ích của Cloud Computing với Big Data là ?",
                options: [
                    "Triển khai hạ tầng nhanh chóng",
                    "Phân tích theo thời gian thực",
                    "Tối ưu chi phí duy trì hoạt động",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Điện toán đám mây mang lại nhiều lợi ích cho Big Data, bao gồm triển khai nhanh, phân tích thời gian thực và tối ưu chi phí."
            },
            {
                question: "Lợi ích vượt trội của Cloud Computing với Big Data là ?",
                options: [
                    "Hạn chế đầu tư máy móc",
                    "Phân tích theo thời gian thực",
                    "Tối ưu chi phí duy trì hoạt động",
                    "Tất cả"
                ],
                answer: "A",
                hint: "Lợi ích vượt trội là giảm thiểu đầu tư ban đầu vào phần cứng."
            },
            {
                question: "Dịch vụ lưu trữ dữ của Amazon - AWS là?",
                options: [
                    "Amazon S3",
                    "Amazon RDS",
                    "Amazon Lambda",
                    "EC2"
                ],
                answer: "A",
                hint: "Amazon S3 (Simple Storage Service) là dịch vụ lưu trữ đối tượng của AWS."
            },
            {
                question: "Dịch vụ lưu trữ của Microsoft Azure là ?",
                options: [
                    "Virtual Machines",
                    "Azure Function",
                    "Azure Disk Storage",
                    "Azure Cosmos DB"
                ],
                answer: "C",
                hint: "Azure Disk Storage là dịch vụ lưu trữ đĩa của Azure."
            },
            {
                question: "Dịch vụ lưu trữ của Google Cloud Platfom là?",
                options: [
                    "Google Driver",
                    "Goolge Functions",
                    "Google Cloud Storage",
                    "Google Cloud Datastore"
                ],
                answer: "C",
                hint: "Google Cloud Storage là dịch vụ lưu trữ đối tượng của Google Cloud."
            },
            {
                question: "Đám mây AWS cung cấp dịch vụ NoSQL Database",
                options: [
                    "Amazon RDS",
                    "Amazon EC2",
                    "Amazon DynamoDB",
                    "Amazon Container Service"
                ],
                answer: "C",
                hint: "Amazon DynamoDB là dịch vụ cơ sở dữ liệu NoSQL của AWS."
            },
            {
                question: "Đám mây Microsoft Azure cung cấp dịch vụ NoSQL Database",
                options: [
                    "Table Storage",
                    "SQL DB",
                    "Azure Functions",
                    "Cloud Service"
                ],
                answer: "A",
                hint: "Azure Table Storage là dịch vụ NoSQL key-value của Azure."
            },
            {
                question: "Dịch vụ tích hợp dữ liệu trên đám mây trên Google Cloud Platform",
                options: [
                    "Google Cloud Dataprep",
                    "Google Cloud Data Fusion",
                    "Google Data Catalog",
                    "Google BigQuery"
                ],
                answer: "B",
                hint: "Google Cloud Data Fusion là dịch vụ tích hợp dữ liệu được quản lý hoàn toàn."
            },
            {
                question: "Dịch vụ thông minh giúp khái phá, làm sạch dữ liệu trên Google Cloud Platform",
                options: [
                    "Goolge Functions",
                    "Google BigQuery",
                    "Google Cloud Dataprep",
                    "Google Data Catalog"
                ],
                answer: "C",
                hint: "Google Cloud Dataprep là dịch vụ giúp khám phá, làm sạch và chuẩn bị dữ liệu."
            },
            {
                question: "Trên Google Cloud Platform dịch vụ nào quản lý CSDL NoQuery",
                options: [
                    "Google Cloud Dataprep",
                    "Google Data Catalog",
                    "Google BigQuery",
                    "Cloud Bigtable"
                ],
                answer: "D",
                hint: "Cloud Bigtable là dịch vụ NoSQL Wide-column của Google Cloud."
            },
            {
                question: "Trên Google Cloud Platform dịch vụ nào quản lý danh mục dữ liệu",
                options: [
                    "Google Data Catalog",
                    "Google Cloud Dataprep",
                    "Google Data Catalog",
                    "Google BigQuery"
                ],
                answer: "A",
                hint: "Google Data Catalog là dịch vụ quản lý siêu dữ liệu và danh mục dữ liệu."
            },
            {
                question: "Trên Google Cloud Platform dịch vụ phân tích dữ liệu được cung cấp",
                options: [
                    "Google Data Catalog",
                    "Google BigQuery",
                    "Google Cloud Dataprep",
                    "Goolge Functions"
                ],
                answer: "B",
                hint: "Google BigQuery là kho dữ liệu và dịch vụ phân tích dữ liệu lớn của Google Cloud."
            },
            {
                question: "Nền tảng Cloudera hỗ trợ hệ CSDL quan hệ nào?",
                options: [
                    "MySQL",
                    "Oracle",
                    "PostgreSQL",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Cloudera hỗ trợ tích hợp với nhiều hệ quản trị CSDL quan hệ khác nhau."
            },
            {
                question: "Hệ CSDL NoSQL trên nền tảng Cloudera là ?",
                options: [
                    "Apache Accumulo",
                    "DynamoDB",
                    "AppEngine Datastore",
                    "Table Storage"
                ],
                answer: "A",
                hint: "Apache Accumulo là một trong những CSDL NoSQL được hỗ trợ trên nền tảng Cloudera."
            },
            {
                question: "Dịch vụ phân tích dữ liệu lớn Cloudera cung cấp là? (Câu 78)",
                options: [
                    "Hadoop",
                    "BigQuery",
                    "Elastic MapReduce",
                    "Không có"
                ],
                answer: "A",
                hint: "Cloudera tập trung vào Hadoop để phân tích dữ liệu lớn."
            },
            {
                question: "Cloudera Enterprise có thể được triển khai trên đám mây nào",
                options: [
                    "Google Cloud",
                    "Amazon AWS",
                    "Tất cả",
                    "Microsoft Azure"
                ],
                answer: "C",
                hint: "Cloudera Enterprise có thể triển khai trên nhiều nền tảng đám mây, bao gồm Google Cloud, AWS và Azure."
            },
            {
                question: "Công cụ trên Google Cloud Platform chuyển đổi dữ liệu hỗ trợ quyết định",
                options: [
                    "Google Cloud",
                    "Google Data Catalog",
                    "Google Data Studio",
                    "Goolge Functions"
                ],
                answer: "C",
                hint: "Google Data Studio (nay là Looker Studio) là công cụ trực quan hóa và báo cáo dữ liệu."
            },
            {
                question: "Mô hình chính dành cho Điện toán đám mây ?",
                options: [
                    "Cơ sở hạ tầng dưới dạng dịch vụ (IaaS)",
                    "Tất cả",
                    "Nền tảng dưới dạng dịch vụ (PaaS)",
                    "Phần mềm dưới dạng dịch vụ (SaaS)"
                ],
                answer: "B",
                hint: "Các mô hình chính của Điện toán đám mây bao gồm IaaS, PaaS và SaaS."
            },
            {
                question: "Kiểu phân tích dữ liệu nào cho ta biết điều gì đã xảy ra?",
                options: [
                    "Descriptive Analysis",
                    "Diagnostic Analysis",
                    "Predictive Analysis",
                    "Prescriptive Analysis"
                ],
                answer: "A",
                hint: "Phân tích mô tả (Descriptive Analysis) giúp hiểu về những gì đã xảy ra trong quá khứ."
            },
            {
                question: "Kiểu phân tích dữ liệu nào chuẩn đoán lý do cho kết quả ?",
                options: [
                    "Descriptive Analysis",
                    "Diagnostic Analysis",
                    "Predictive Analysis",
                    "Prescriptive Analysis"
                ],
                answer: "B",
                hint: "Phân tích chuẩn đoán (Diagnostic Analysis) tìm hiểu lý do tại sao một sự kiện xảy ra."
            },
            {
                question: "Kiểu phân tích dữ liệu nào dự đoán điều sẽ xảy ra ?",
                options: [
                    "Descriptive Analysis",
                    "Diagnostic Analysis",
                    "Predictive Analysis",
                    "Prescriptive Analysis"
                ],
                answer: "C",
                hint: "Phân tích dự đoán (Predictive Analysis) tập trung vào việc dự đoán tương lai."
            },
            {
                question: "Kiểu phân tích nào để hỗ trợ đưa ra quyết định ?",
                options: [
                    "Descriptive Analysis",
                    "Diagnostic Analysis",
                    "Predictive Analysis",
                    "Prescriptive Analysis"
                ],
                answer: "D",
                hint: "Phân tích đề xuất (Prescriptive Analysis) cung cấp các khuyến nghị để đưa ra quyết định tối ưu."
            },
            {
                question: "Loại phân tích dữ liệu nào kết quả thu được cho ta biết điều gì đã xảy ra ?",
                options: [
                    "Phân tích mô tả",
                    "Phân tích chuẩn đoán",
                    "Phân tích dự đoán",
                    "Phân tích đề xuất"
                ],
                answer: "A",
                hint: "Phân tích mô tả trả lời câu hỏi 'điều gì đã xảy ra'."
            },
            {
                question: "Loại phân tích dữ liệu nào kết quả thu được cho ta biết tại sao điều đó xảy ra?",
                options: [
                    "Phân tích mô tả",
                    "Phân tích chuẩn đoán",
                    "Phân tích dự đoán",
                    "Phân tích đề xuất"
                ],
                answer: "B",
                hint: "Phân tích chuẩn đoán trả lời câu hỏi 'tại sao điều đó xảy ra'."
            },
            {
                question: "Loại phân tích dữ liệu nào kết quả thu được cho ta biết điều gì sẽ xảy ra ? (Câu 88)",
                options: [
                    "Phân tích mô tả",
                    "Phân tích chuẩn đoán",
                    "Phân tích dự đoán",
                    "Phân tích đề xuất"
                ],
                answer: "C",
                hint: "Phân tích dự đoán trả lời câu hỏi 'điều gì sẽ xảy ra'."
            },
            {
                question: "Loại phân tích dữ liệu nào kết quả thu được cho ta biết làm thể nào để nó xảy ra (Câu 89)",
                options: [
                    "Phân tích mô tả",
                    "Phân tích chuẩn đoán",
                    "Phân tích dự đoán",
                    "Phân tích đề xuất"
                ],
                answer: "D",
                hint: "Phân tích đề xuất trả lời câu hỏi 'làm thế nào để nó xảy ra'."
            },
            {
                question: "Mục tiêu đúng nhất của phân tích dữ liệu lớn là gì ? (Câu 90)",
                options: [
                    "Biến dữ liệu thành thông tin chi tiết hữu ích",
                    "Sắp xếp dữ liệu có ích để sử dụng",
                    "Tạo ra các dữ liệu phù hợp nhất với hệ thống",
                    "Xây dựng hệ thống để quản lý dữ liệu lớn"
                ],
                answer: "A",
                hint: "Mục tiêu chính của phân tích dữ liệu lớn là trích xuất thông tin giá trị để hỗ trợ ra quyết định."
            },
            {
                question: "Hoạt động của Map Reduce bao gồm: (Câu 91)",
                options: [
                    "Trộn & sắp xếp - Map - Reduce",
                    "Map - Trộn & sắp xếp – Reduce",
                    "Reduce - Map - Trộn & sắp xếp",
                    "Sắp xếp - Trộn & Map – Reduce"
                ],
                answer: "B",
                hint: "Thứ tự hoạt động của MapReduce là Map (ánh xạ), Shuffle & Sort (trộn và sắp xếp), sau đó là Reduce (giảm)."
            },
            {
                question: "Phân tích chuẩn đoán sử dụng kỹ thuật nào ? (Câu 92)",
                options: [
                    "Lấy mẫu dữ liệu",
                    "Tương quan phân bổ",
                    "Thu tập dữ liệu",
                    "Khai phá dữ liệu"
                ],
                answer: "B",
                hint: "Phân tích chuẩn đoán thường sử dụng kỹ thuật tương quan phân bổ để tìm hiểu mối quan hệ giữa các biến."
            },
            {
                question: "Phân tích chuẩn đoán sử dụng kỹ thuật nào ? (Câu 93)",
                options: [
                    "Lấy mẫu mô tả",
                    "Tương quan phân bổ",
                    "Khôi phục dữ liệu",
                    "Thu tập dữ liệu"
                ],
                answer: "B",
                hint: "Tương quan phân bổ là một kỹ thuật được sử dụng trong phân tích chuẩn đoán."
            },
            {
                question: "Phân tích mô tả không phù hợp sử dụng để ? (Câu 94)",
                options: [
                    "Xây dựng các báo cáo",
                    "Lập bảng số liệu truyền thông",
                    "Mô hình hoá dữ liệu quá khứ",
                    "Phân tích tương quan"
                ],
                answer: "D",
                hint: "Phân tích mô tả tập trung vào việc mô tả dữ liệu đã có, ít dùng để phân tích tương quan sâu sắc."
            },
            {
                question: "Đâu là phân tích chuẩn đoán ? (Câu 95)",
                options: [
                    "Mô tả tương quan dữ liệu",
                    "Cung cấp cái nhinh sâu sắc về vấn đề",
                    "Phân tích sự bất thường từ dữ liệu lưu trữ",
                    "Mô hình hoá dữ liệu theo điều kiện"
                ],
                answer: "C",
                hint: "Phân tích chuẩn đoán thường bao gồm việc phân tích sự bất thường hoặc các vấn đề từ dữ liệu."
            },
            {
                question: "Trong MapReduce loại nào sau đây theo dõi quá trình tiêu thụ tài nguyên trên Cluster Node? (Câu 96)",
                options: [
                    "Name node",
                    "Master node",
                    "Single Master",
                    "Slave node"
                ],
                answer: "B",
                hint: "Master node (JobTracker) trong MapReduce chịu trách nhiệm theo dõi tài nguyên và tiến độ công việc."
            },
            {
                question: "Trong MapReduce loại nào sau đây thực thi các tác vụ và cung cấp thông tin trạng thai tác vụ? (Câu 97)",
                "options": [
                    "Name node",
                    "Master node",
                    "Single Master",
                    "Slave node"
                ],
                answer: "D",
                hint: "Slave node (TaskTracker) thực thi các tác vụ và báo cáo trạng thái về Master."
            },
            {
                question: "Trong MapReduce loại nào sau đây được cung cấp task-status? (Câu 98)",
                options: [
                    "Name node",
                    "JobTracker",
                    "Single Master",
                    "Slave node"
                ],
                answer: "B",
                hint: "TaskTracker cung cấp task status cho JobTracker."
            },
            {
                question: "Mô hình MapReduce có thể chạy trên số lượng máy chủ? (Câu 99)",
                options: [
                    "Vài máy",
                    "Hàng nghìn máy",
                    "Hàng trăm máy",
                    "Một máy chủ Master"
                ],
                answer: "B",
                hint: "MapReduce được thiết kế để mở rộng trên hàng nghìn máy chủ."
            },
            {
                question: "Mô hình MapReduce thuộc lớp nào ? (Câu 100)",
                options: [
                    "Lớp lưu trữ dữ liệu",
                    "Lớp thu thập dữ liệu",
                    "Lớp xử lý dữ liệu",
                    "Lớp phân tích dữ liệu"
                ],
                answer: "C",
                hint: "MapReduce là một khung xử lý dữ liệu phân tán."
            },
            {
                question: "Lợi ích từ Phân tích dữ liệu lớn là ? (Câu 101)",
                options: [
                    "Tất cả",
                    "Ra quyết định nhanh hơn, tốt hơn",
                    "Giảm chi phí và tăng hiệu quả hoạt động",
                    "Cải tiến theo định hướng dữ liệu cho thị trường"
                ],
                answer: "A",
                hint: "Phân tích dữ liệu lớn mang lại nhiều lợi ích, bao gồm cải thiện quyết định, giảm chi phí và thúc đẩy đổi mới."
            },
            {
                question: "Các ứng dụng phân tích dữ liệu lớn cho Lĩnh vực bán lẻ (Câu 102)",
                options: [
                    "Dự đoán hành vi mua sắm của khách hàng",
                    "Xây dựng mô hình chi tiêu cho từng khách hàng",
                    "Phân tích hành trình của khách hàng",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Trong bán lẻ, Big Data giúp dự đoán hành vi, xây dựng hồ sơ khách hàng và phân tích hành trình mua sắm."
            },
            {
                question: "Ứng dụng phân tích dữ liệu lớn hỗ trợ ngành Y tế (Câu 103)",
                options: [
                    "Tăng việc khai thác tối ưu hoá máy móc",
                    "Tăng doanh thu từ phần mềm y tế",
                    "Tăng tỉnh chính xác của chẩn đoán",
                    "Tất cả"
                ],
                answer: "C",
                hint: "Trong y tế, Big Data đặc biệt giúp tăng độ chính xác trong chẩn đoán và điều trị."
            },
            {
                question: "Trong kiến trúc Apache Hadoop HDFS thuộc (Câu 104)",
                options: [
                    "Lớp lưu trữ",
                    "Lớp truyền tải",
                    "Lớp quản lý tài nguyên",
                    "Lớp xử lý dữ liệu"
                ],
                answer: "A",
                hint: "HDFS (Hadoop Distributed File System) là lớp lưu trữ dữ liệu của Hadoop."
            },
            {
                question: "Trong kiến trúc Apache Hadoop YARN là (Câu 105)",
                options: [
                    "Lớp lưu trữ",
                    "Lớp truyền tải",
                    "Lớp quản lý tài nguyên",
                    "Lớp xử lý dữ liệu"
                ],
                answer: "C",
                hint: "YARN (Yet Another Resource Negotiator) là lớp quản lý tài nguyên của Hadoop."
            },
            {
                question: "Trong kiến trúc Apache Hadoop MapReduce là (Câu 106)",
                options: [
                    "Lớp lưu trữ",
                    "Lớp truyền tải",
                    "Lớp quản lý tài nguyên",
                    "Lớp xử lý dữ liệu"
                ],
                answer: "D",
                hint: "MapReduce là một mô hình/lớp xử lý dữ liệu trong Hadoop."
            },
            {
                question: "Kiến trúc Hadoop hỗ trợ những ngôn ngữ nào (Câu 107)",
                options: [
                    "Java",
                    "Tất cả",
                    "C++",
                    "Python"
                ],
                answer: "B",
                hint: "Mặc dù Hadoop cốt lõi được viết bằng Java, nhưng nó hỗ trợ các API cho nhiều ngôn ngữ khác nhau."
            },
            {
                question: "Spark được Apache Software Foundation phát triển từ năm nào (Câu 108)",
                options: [
                    "1993",
                    "2013",
                    "2009",
                    "2007"
                ],
                answer: "C",
                hint: "Apache Spark được phát triển ban đầu tại UC Berkeley AMPLab vào năm 2009."
            },
            {
                question: "Apache Kafka là công cụ hỗ trợ ? (Câu 109)",
                options: [
                    "Xử lý phân tán",
                    "Lưu trữ phân tán",
                    "Hệ quản trị CSDL",
                    "Thu tập dữ liệu"
                ],
                answer: "D",
                hint: "Apache Kafka là một nền tảng streaming events, thường dùng để thu thập và truyền tải dữ liệu."
            },
            {
                question: "Apache Storm là công cụ hỗ trợ? (Câu 110)",
                options: [
                    "Xử lý phân tán",
                    "Lưu trữ phân tán",
                    "Phân tích dữ liệu",
                    "Thu tập dữ liệu"
                ],
                answer: "A",
                hint: "Apache Storm là một hệ thống xử lý phân tán theo thời gian thực."
            },
            {
                question: "Đâu không phải là chế độ hoạt động của Hadoop? (Câu 111)",
                options: [
                    "Chế độ phân phối giả",
                    "Chế độ phân phối toàn cầu",
                    "Chế độ độc lập",
                    "Chế độ phân phối hoàn toàn"
                ],
                answer: "B",
                hint: "Hadoop có các chế độ Standalone, Pseudo-distributed và Fully Distributed. Không có 'phân phối toàn cầu'."
            },
            {
                question: "Các tệp HDFS được thiết kế cho (Câu 112)",
                options: [
                    "Nhiều người viết và sửa đổi ở các hiệu số tùy ý.",
                    "Chỉ nối vào cuối tệp",
                    "Chỉ ghi thành tệp một lần.",
                    "Truy cập dữ liệu có độ trễ thấp."
                ],
                answer: "C",
                hint: "HDFS được tối ưu cho việc ghi một lần và đọc nhiều lần."
            },
            {
                question: "Tính năng định vị dữ liệu trong Hadoop có nghĩa là (Câu 113)",
                options: [
                    "Lưu trữ cùng một dữ liệu trên nhiều nút.",
                    "Chuyển vị trí dữ liệu từ nút này sang nút khác.",
                    "Đồng định vị dữ liệu với các nút tính toán.",
                    "Phân phối dữ liệu trên nhiều nút."
                ],
                answer: "C",
                hint: "Data locality là việc đặt tính toán gần dữ liệu để giảm di chuyển dữ liệu qua mạng."
            },
            {
                question: "Khó khăn khi đọc và ghi dữ liệu song song từ nhiều nguồn là gì? (Câu 114)",
                options: [
                    "Xử lý khối lượng lớn dữ liệu nhanh hơn.",
                    "Kết hợp dữ liệu từ nhiều nguồn.",
                    "Phần mềm cần thiết để thực hiện nhiệm vụ này là cực kỳ tốn kém.",
                    "Phần cứng cần thiết để thực hiện tác vụ này là cực kỳ tốn kém."
                ],
                answer: "B",
                hint: "Thách thức chính là việc tổng hợp và quản lý dữ liệu từ nhiều nguồn khác nhau."
            },
            {
                question: "So với RDBMS, Hadoop (Câu 115)",
                options: [
                    "Có tính toàn vẹn dữ liệu cao hơn.",
                    "Có giao dịch ACID không",
                    "Nó thích hợp để đọc và viết nhiều lần",
                    "Hoạt động tốt hơn trên dữ liệu phi cấu trúc và bán cấu trúc."
                ],
                answer: "D",
                hint: "Hadoop vượt trội trong việc xử lý dữ liệu phi cấu trúc và bán cấu trúc, không phải RDBMS."
            },
            {
                question: "Yếu tố giới hạn hiện tại đối với kích thước của một cụm hadoop là (Câu 116)",
                options: [
                    "Nhiệt lượng dư thừa tạo ra trong trung tâm dữ liệu",
                    "Giới hạn trên của băng thông mạng",
                    "Giới hạn trên của RAM trong NameNode",
                    "4000 datanode"
                ],
                answer: "C",
                hint: "NameNode lưu trữ metadata của HDFS trong RAM, nên RAM của NameNode là một yếu tố giới hạn kích thước cụm."
            },
            {
                question: "Trong HDFS, các tệp không thể (Câu 117)",
                options: [
                    "Đọc",
                    "Xoá",
                    "Thực thi",
                    "Lưu trữ"
                ],
                answer: "C",
                hint: "HDFS là hệ thống tệp phân tán, không phải hệ thống thực thi lệnh."
            },
            {
                question: "Điều nào sau đây không phải là mục tiêu của HDFS? (Câu 118)",
                options: [
                    "Phát hiện lỗi và khôi phục",
                    "Xử lý tập dữ liệu khổng lồ",
                    "Ngăn chặn việc xóa dữ liệu",
                    "Cung cấp băng thông mạng cao để di chuyển dữ liệu"
                ],
                answer: "C",
                hint: "HDFS không nhằm mục đích ngăn chặn việc xóa dữ liệu; nó tập trung vào khả năng chịu lỗi và xử lý dữ liệu lớn."
            },
            {
                question: "YARN là viết tắt của (Câu 119)",
                options: [
                    "Yahoo's another resource name",
                    "Yet another resource negotiator",
                    "Yahoo's archived Resource names",
                    "Yet another resource need."
                ],
                answer: "B",
                hint: "YARN là viết tắt của Yet Another Resource Negotiator."
            },
            {
                question: "Kiến trúc HDFS trong Hadoop có nguồn gốc là (Câu 120)",
                options: [
                    "Hệ thống tệp phân phối của Google",
                    "Hệ thống tệp phân tán của Yahoo",
                    "Hệ thống tệp phân tán của Facebook",
                    "Hệ thống tệp phân tán của Azure"
                ],
                answer: "A",
                hint: "HDFS được lấy cảm hứng từ Google File System (GFS)."
            },
            {
                question: "HDFS là viết tắt của (Câu 121)",
                options: [
                    "Hệ thống tệp phân tán cao. (Highly distributed file system.)",
                    "Hệ thống tệp được hướng dẫn Hadoop. (Hadoop directed file system)",
                    "Hệ tệp phân tán cao. (Highly distributed file shell)",
                    "Hệ thống tệp phân tán Hadoop. (Hadoop distributed file system)"
                ],
                answer: "D",
                hint: "HDFS là viết tắt của Hadoop Distributed File System."
            },
            {
                question: "Thành phân nào không thuộc Hadoop? (Câu 122)",
                options: [
                    "YARN",
                    "HDFS",
                    "MapReduce",
                    "GFS"
                ],
                answer: "D",
                hint: "GFS (Google File System) là tiền thân của HDFS, nhưng GFS không phải là một thành phần của Hadoop."
            },
            {
                question: "Thành phần chính của hệ thống Hadoop là ? (Câu 123)",
                options: [
                    "MapReduce",
                    "HDFS",
                    "YARN",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Các thành phần chính của Hadoop bao gồm HDFS (lưu trữ), YARN (quản lý tài nguyên) và MapReduce (xử lý)."
            },
            {
                question: "Apache Kafka là nền tảng mở được phát triển bởi ? (Câu 124)",
                options: [
                    "LinkedIn",
                    "Facebook",
                    "Google",
                    "IBM"
                ],
                answer: "A",
                hint: "Apache Kafka ban đầu được phát triển bởi LinkedIn."
            },
            {
                question: "Công cụ nào hỗ trợ tích hợp dữ liệu (Câu 125)",
                options: [
                    "Dell Boomi",
                    "Snaplogic",
                    "SAP Data Services",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Dell Boomi, Snaplogic, và SAP Data Services đều là các công cụ tích hợp dữ liệu."
            }
        ];

        let currentQuestionIndex = 0; // Index in currentQuizOrder
        let questionStates = Array.from({ length: quizData.length }, () => ({
            userAnswer: null, // Index of selected option (0, 1, 2, 3)
            status: 'unanswered', // 'unanswered', 'correct', 'incorrect'
            isMarkedForReview: false // true if marked for review
        }));
        let shuffledOptions = []; // Stores shuffled options for current question display
        let currentQuizOrder = []; // Stores the shuffled order of original quizData indices
        let timerInterval;
        let timeLeft;
        let isTimerRunning = false;

        const questionNumberElem = document.getElementById('questionNumber');
        const questionTextElem = document.getElementById('questionText');
        const optionsContainerElem = document.getElementById('optionsContainer');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const checkAnswerBtn = document.getElementById('checkAnswerBtn');
        const shuffleAnswersToggle = document.getElementById('shuffleAnswers');
        const shuffleQuestionsOrderToggle = document.getElementById('shuffleQuestionsOrder');
        const studyModeToggle = document.getElementById('studyModeToggle');
        const markForReviewBtn = document.getElementById('markForReviewBtn');
        const questionNav = document.getElementById('questionNav');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const resetQuizBtn = document.getElementById('resetQuizBtn');
        const quizSummary = document.getElementById('quizSummary');
        const incorrectQuestionsList = document.getElementById('incorrectQuestionsList');
        const markedQuestionsList = document.getElementById('markedQuestionsList');

        const timeLimitInput = document.getElementById('timeLimitInput');
        const timerDisplay = document.getElementById('timerDisplay');
        const startTimerBtn = document.getElementById('startTimerBtn');
        const pauseTimerBtn = document.getElementById('pauseTimerBtn');
        const resetTimerBtn = document.getElementById('resetTimerBtn');
        const progressBarFill = document.getElementById('progressBarFill');

        const messageBoxOverlay = document.getElementById('messageBoxOverlay');
        const messageBox = document.getElementById('messageBox');
        const messageBoxTitle = document.getElementById('messageBoxTitle');
        const messageBoxContent = document.getElementById('messageBoxContent');
        const messageBoxButton = document.getElementById('messageBoxButton');

        // Function to show custom message box
        function showMessageBox(title, content, onConfirm = null) {
            messageBoxTitle.textContent = title;
            messageBoxContent.textContent = content;
            messageBoxOverlay.style.display = 'block';
            messageBox.style.display = 'flex';
            pauseTimer(); // Pause timer when message box is open
            messageBoxButton.onclick = () => {
                messageBoxOverlay.style.display = 'none';
                messageBox.style.display = 'none';
                if (onConfirm) {
                    onConfirm();
                } else if (isTimerRunning) {
                    startTimer(); // Resume timer if it was running
                }
            };
        }

        // Function to shuffle an array (Fisher-Yates algorithm)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Function to map A, B, C, D to indices 0, 1, 2, 3
        function getOptionIndex(optionLetter) {
            return optionLetter.charCodeAt(0) - 'A'.charCodeAt(0);
        }

        // Function to map indices 0, 1, 2, 3 to A, B, C, D
        function getOptionLetter(optionIndex) {
            return String.fromCharCode('A'.charCodeAt(0) + optionIndex);
        }

        // Function to initialize question order (shuffled or sequential)
        function initializeQuizOrder() {
            if (shuffleQuestionsOrderToggle.checked) {
                currentQuizOrder = shuffleArray(Array.from({ length: quizData.length }, (_, i) => i));
            } else {
                currentQuizOrder = Array.from({ length: quizData.length }, (_, i) => i);
            }
        }

        // Function to display the current question
        function displayQuestion() {
            const originalQuestionIndex = currentQuizOrder[currentQuestionIndex];
            const questionData = quizData[originalQuestionIndex];
            const questionState = questionStates[originalQuestionIndex];

            questionNumberElem.textContent = `Câu ${currentQuestionIndex + 1}/${quizData.length}`;
            questionTextElem.textContent = questionData.question;
            optionsContainerElem.innerHTML = '';

            // Create a copy of options to shuffle
            let optionsToDisplay = [...questionData.options];

            if (shuffleAnswersToggle.checked) {
                // Shuffle options, keeping originalIdx
                shuffledOptions = shuffleArray(optionsToDisplay.map((opt, idx) => ({ opt, originalIdx: idx })));
            } else {
                // Keep original order
                shuffledOptions = optionsToDisplay.map((opt, idx) => ({ opt, originalIdx: idx }));
            }

            const hasBeenChecked = questionState.status !== 'unanswered';
            const correctOptionIndex = getOptionIndex(questionData.answer);

            shuffledOptions.forEach((item, index) => {
                const optionButton = document.createElement('button');
                optionButton.classList.add('option-button', 'rounded-lg', 'focus:outline-none');
                optionButton.dataset.originalIndex = item.originalIdx; // Store original index of the option
                optionButton.innerHTML = `${getOptionLetter(index)}. ${item.opt}`; // Display option letter and text
                optionsContainerElem.appendChild(optionButton);

                if (hasBeenChecked || isTimerFinished()) { // If question checked or timer finished, disable options
                    optionButton.classList.add('disabled');
                    optionButton.disabled = true;

                    // Highlight correct answer and bold it
                    if (item.originalIdx === correctOptionIndex) {
                        optionButton.classList.add('correct');
                        optionButton.classList.remove('selected');
                        optionButton.innerHTML = `${getOptionLetter(index)}. <b>${item.opt}</b>`; // Bold correct answer
                    }
                    // Highlight user's selected answer (if any) and mark incorrect if wrong
                    if (item.originalIdx === questionState.userAnswer) {
                        optionButton.classList.add('selected');
                        if (questionState.userAnswer !== correctOptionIndex) {
                            optionButton.classList.add('incorrect');
                        }
                    }
                } else {
                    // Attach click event listener if not checked and timer not finished
                    optionButton.addEventListener('click', () => selectOption(item.originalIdx, optionButton));
                    // If user previously selected an answer, highlight it
                    if (questionState.userAnswer !== null && item.originalIdx === questionState.userAnswer) {
                        optionButton.classList.add('selected');
                    }
                }
            });

            updateNavigationButtons();
            updateQuestionNavButtons();
            updateMarkForReviewButton();
            updateProgressBar();
            quizSummary.classList.add('hidden'); // Hide summary when navigating questions
        }

        // Function to select an option
        function selectOption(selectedIndex, clickedButton) {
            const originalQuestionIndex = currentQuizOrder[currentQuestionIndex];
            const questionState = questionStates[originalQuestionIndex];

            // Only allow selection if not already checked and timer is not finished
            if (questionState.status === 'unanswered' && !isTimerFinished()) {
                // Remove previous selection
                document.querySelectorAll('.option-button').forEach(btn => {
                    btn.classList.remove('selected');
                });

                // Highlight new selection
                clickedButton.classList.add('selected');
                questionState.userAnswer = selectedIndex; // Store user's answer based on original index

                // If in study mode, check answer immediately
                if (studyModeToggle.checked) {
                    checkAnswer();
                } else {
                    // Otherwise, enable check answer button
                    checkAnswerBtn.disabled = false;
                }
            }
        }

        // Function to check the answer
        function checkAnswer() {
            const originalQuestionIndex = currentQuizOrder[currentQuestionIndex];
            const questionData = quizData[originalQuestionIndex];
            const questionState = questionStates[originalQuestionIndex];

            if (questionState.userAnswer === null && !isTimerFinished()) {
                showMessageBox('Chưa chọn đáp án', 'Vui lòng chọn một đáp án trước khi kiểm tra.');
                return;
            }

            // Disable all option buttons after checking
            document.querySelectorAll('.option-button').forEach(btn => {
                btn.classList.add('disabled');
                btn.disabled = true;
            });

            const correctOptionIndex = getOptionIndex(questionData.answer);
            const userAnswerIndex = questionState.userAnswer;

            // Highlight correct/incorrect answers on UI and bold correct answer
            shuffledOptions.forEach((item, index) => {
                const optionButton = optionsContainerElem.children[index];
                if (item.originalIdx === correctOptionIndex) {
                    optionButton.classList.add('correct');
                    optionButton.classList.remove('selected');
                    optionButton.innerHTML = `${getOptionLetter(index)}. <b>${item.opt}</b>`; // Bold correct answer
                } else if (item.originalIdx === userAnswerIndex) {
                    optionButton.classList.add('incorrect');
                }
            });

            // Update question status based on original index
            if (userAnswerIndex === correctOptionIndex) {
                questionState.status = 'correct';
            } else {
                questionState.status = 'incorrect';
            }

            // Disable check answer button after checking (if not in study mode)
            if (!studyModeToggle.checked) {
                checkAnswerBtn.disabled = true;
            }

            updateQuestionNavButtons(); // Update navigation button colors
            updateNavigationButtons(); // Update navigation button states (hide/show check button)
        }

        // Function to update navigation button states
        function updateNavigationButtons() {
            prevBtn.disabled = currentQuestionIndex === 0;
            nextBtn.disabled = currentQuestionIndex === quizData.length - 1;

            const originalQuestionIndex = currentQuizOrder[currentQuestionIndex];
            const questionState = questionStates[originalQuestionIndex];
            const hasAnswered = questionState.userAnswer !== null;
            const hasBeenChecked = questionState.status !== 'unanswered';
            const timerFinished = isTimerFinished();

            // Hide or show check answer button based on study mode and timer status
            if (studyModeToggle.checked || timerFinished) {
                checkAnswerBtn.classList.add('hidden');
            } else {
                checkAnswerBtn.classList.remove('hidden');
                checkAnswerBtn.disabled = !hasAnswered || hasBeenChecked;
            }

            // Mark for Review button state
            markForReviewBtn.disabled = timerFinished;

            // Show Reset button and summary if all questions are answered/checked or timer finished
            const allAnsweredOrChecked = questionStates.every(state => state.status !== 'unanswered');
            if ((currentQuestionIndex === quizData.length - 1 && allAnsweredOrChecked) || timerFinished) {
                resetQuizBtn.classList.remove('hidden');
                scoreDisplay.classList.remove('hidden');
                calculateScore();
                displayQuizSummary(); // Show summary
                pauseTimer(); // Ensure timer is paused at the end
            } else {
                resetQuizBtn.classList.add('hidden');
                scoreDisplay.classList.add('hidden');
                quizSummary.classList.add('hidden'); // Ensure summary is hidden
            }
        }

        // Function to navigate between questions
        function navigate(direction) {
            if (direction === 'prev' && currentQuestionIndex > 0) {
                currentQuestionIndex--;
            } else if (direction === 'next' && currentQuestionIndex < quizData.length - 1) {
                currentQuestionIndex++;
            }
            displayQuestion();
        }

        // Function to create question navigation buttons (1, 2, 3...)
        function createQuestionNavigation() {
            questionNav.innerHTML = '';
            for (let i = 0; i < quizData.length; i++) {
                const button = document.createElement('button');
                button.classList.add('question-nav-button');
                button.textContent = i + 1; // Display original question number
                button.dataset.originalIndex = i; // Store original index
                
                const displayIndex = currentQuizOrder.indexOf(i);
                
                if (displayIndex === currentQuestionIndex) {
                    button.classList.add('active');
                }
                button.addEventListener('click', () => {
                    currentQuestionIndex = displayIndex; // Navigate to the question's display position
                    displayQuestion();
                });
                questionNav.appendChild(button);
            }
            updateQuestionNavButtons();
        }

        // Function to update colors of question navigation buttons based on quiz status
        function updateQuestionNavButtons() {
            document.querySelectorAll('.question-nav-button').forEach(button => {
                button.classList.remove('active', 'answered-correctly', 'answered-incorrectly', 'marked-for-review');
                
                const originalIdx = parseInt(button.dataset.originalIndex);
                const questionState = questionStates[originalIdx];
                
                if (currentQuizOrder[currentQuestionIndex] === originalIdx) {
                    button.classList.add('active');
                }

                if (questionState.status === 'correct') {
                    button.classList.add('answered-correctly');
                } else if (questionState.status === 'incorrect') {
                    button.classList.add('answered-incorrectly');
                }

                if (questionState.isMarkedForReview) {
                    button.classList.add('marked-for-review');
                }
            });
        }

        // Function to calculate and display score
        function calculateScore() {
            let correctCount = 0;
            for (let i = 0; i < quizData.length; i++) {
                const question = quizData[i];
                const questionState = questionStates[i];
                if (questionState.userAnswer !== null) {
                    const correctIndex = getOptionIndex(question.answer);
                    if (questionState.userAnswer === correctIndex) {
                        correctCount++;
                    }
                }
            }
            scoreDisplay.textContent = `Bạn đã trả lời đúng ${correctCount}/${quizData.length} câu.`;
        }

        // Function to display summary of incorrect and marked questions
        function displayQuizSummary() {
            incorrectQuestionsList.innerHTML = '';
            markedQuestionsList.innerHTML = '';
            let hasIncorrectAnswers = false;
            let hasMarkedQuestions = false;

            // Iterate through original quizData indices for summary
            quizData.forEach((question, originalIdx) => {
                const questionState = questionStates[originalIdx];
                const correctOptionText = question.options[getOptionIndex(question.answer)];

                if (questionState.status === 'incorrect') {
                    hasIncorrectAnswers = true;
                    const itemDiv = document.createElement('div');
                    itemDiv.classList.add('incorrect-question-item');
                    itemDiv.innerHTML = `
                        <p class="question-text-summary">Câu ${originalIdx + 1}: ${question.question}</p>
                        <p>Đáp án đúng: <span class="correct-answer-summary"><b>${correctOptionText}</b></span></p>
                        <p class="hint-summary">Gợi ý: ${question.hint || 'Không có gợi ý cụ thể.'}</p>
                    `;
                    incorrectQuestionsList.appendChild(itemDiv);
                }
                if (questionState.isMarkedForReview) {
                    hasMarkedQuestions = true;
                    const itemDiv = document.createElement('div');
                    itemDiv.classList.add('marked-question-item');
                    itemDiv.innerHTML = `
                        <p class="question-text-summary">Câu ${originalIdx + 1}: ${question.question}</p>
                        <p>Đáp án đúng: <span class="correct-answer-summary"><b>${correctOptionText}</b></span></p>
                        <p class="hint-summary">Gợi ý: ${question.hint || 'Không có gợi ý cụ thể.'}</p>
                    `;
                    markedQuestionsList.appendChild(itemDiv);
                }
            });

            if (!hasIncorrectAnswers) {
                incorrectQuestionsList.innerHTML = '<p class="no-items-message">Không có câu trả lời sai!</p>';
            }
            if (!hasMarkedQuestions) {
                markedQuestionsList.innerHTML = '<p class="no-items-message">Không có câu hỏi nào được đánh dấu để xem lại.</p>';
            }
            
            quizSummary.classList.remove('hidden');
        }

        // Function to update the state of the "Mark for Review" button
        function updateMarkForReviewButton() {
            const originalQuestionIndex = currentQuizOrder[currentQuestionIndex];
            const questionState = questionStates[originalQuestionIndex];
            if (questionState.isMarkedForReview) {
                markForReviewBtn.textContent = 'Bỏ đánh dấu xem lại';
                markForReviewBtn.classList.add('bg-orange-500', 'hover:bg-orange-600');
                markForReviewBtn.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
            } else {
                markForReviewBtn.textContent = 'Đánh dấu xem lại';
                markForReviewBtn.classList.remove('bg-orange-500', 'hover:bg-orange-600');
                markForReviewBtn.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
            }
        }

        // Function to toggle the "Mark for Review" status
        function toggleMarkForReview() {
            const originalQuestionIndex = currentQuizOrder[currentQuestionIndex];
            questionStates[originalQuestionIndex].isMarkedForReview = !questionStates[originalQuestionIndex].isMarkedForReview;
            updateMarkForReviewButton();
            updateQuestionNavButtons(); // Update nav button color
        }

        // Timer functions
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
        }

        function updateTimerDisplay() {
            timerDisplay.textContent = formatTime(timeLeft);
            if (timeLeft <= 0) {
                endQuizByTimer();
            }
        }

        function startTimer() {
            if (isTimerRunning) return;
            isTimerRunning = true;
            startTimerBtn.disabled = true;
            pauseTimerBtn.disabled = false;
            resetTimerBtn.disabled = true; // Disable reset while running
            timeLimitInput.disabled = true; // Disable input when timer starts
            timerInterval = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();
            }, 1000);
        }

        function pauseTimer() {
            if (!isTimerRunning) return;
            isTimerRunning = false;
            clearInterval(timerInterval);
            startTimerBtn.disabled = false;
            pauseTimerBtn.disabled = true;
            resetTimerBtn.disabled = false; // Enable reset when paused
        }

        function resetTimer() {
            pauseTimer();
            const minutes = parseInt(timeLimitInput.value);
            timeLeft = minutes * 60;
            updateTimerDisplay();
            startTimerBtn.disabled = false;
            pauseTimerBtn.disabled = true;
            resetTimerBtn.disabled = false;
            timeLimitInput.disabled = false; // Re-enable input
        }

        function endQuizByTimer() {
            pauseTimer();
            showMessageBox(
                'Hết giờ!',
                'Thời gian làm bài đã kết thúc. Bài thi sẽ được tổng kết.',
                () => {
                    // Mark all unanswered questions as incorrect at the end of timer
                    questionStates.forEach((state, originalIdx) => {
                        if (state.status === 'unanswered') {
                            state.status = 'incorrect';
                        }
                    });
                    currentQuestionIndex = quizData.length - 1; // Move to last question to trigger summary
                    displayQuestion(); // Re-render last question with checked state
                    // The updateNavigationButtons will handle showing summary
                }
            );
        }

        function isTimerFinished() {
            return timeLeft <= 0 && !isTimerRunning;
        }

        function updateProgressBar() {
            const answeredCount = questionStates.filter(state => state.userAnswer !== null).length;
            const progress = (answeredCount / quizData.length) * 100;
            progressBarFill.style.width = `${progress}%`;
        }

        // Reset quiz
        function resetQuiz() {
            showMessageBox(
                'Xác nhận làm lại bài thi',
                'Bạn có chắc chắn muốn làm lại toàn bộ bài thi? Tất cả câu trả lời và thời gian sẽ bị xóa.',
                () => {
                    questionStates = Array.from({ length: quizData.length }, () => ({
                        userAnswer: null,
                        status: 'unanswered',
                        isMarkedForReview: false
                    }));
                    currentQuestionIndex = 0;
                    initializeQuizOrder();
                    displayQuestion();
                    createQuestionNavigation();
                    scoreDisplay.classList.add('hidden');
                    resetQuizBtn.classList.add('hidden');
                    quizSummary.classList.add('hidden');
                    incorrectQuestionsList.innerHTML = '<p class="no-items-message">Không có câu trả lời sai!</p>';
                    markedQuestionsList.innerHTML = '<p class="no-items-message">Không có câu hỏi nào được đánh dấu để xem lại.</p>';
                    if (!studyModeToggle.checked) {
                        checkAnswerBtn.disabled = true;
                        checkAnswerBtn.classList.remove('hidden');
                    }
                    resetTimer(); // Reset timer as part of quiz reset
                    updateProgressBar(); // Reset progress bar
                }
            );
        }

        // Event Listeners
        prevBtn.addEventListener('click', () => navigate('prev'));
        nextBtn.addEventListener('click', () => navigate('next'));
        checkAnswerBtn.addEventListener('click', checkAnswer);
        markForReviewBtn.addEventListener('click', toggleMarkForReview);

        shuffleAnswersToggle.addEventListener('change', displayQuestion);
        shuffleQuestionsOrderToggle.addEventListener('change', resetQuiz);
        studyModeToggle.addEventListener('change', () => {
            updateNavigationButtons();
            displayQuestion();
        });

        resetQuizBtn.addEventListener('click', resetQuiz);

        // Timer Event Listeners
        startTimerBtn.addEventListener('click', startTimer);
        pauseTimerBtn.addEventListener('click', pauseTimer);
        resetTimerBtn.addEventListener('click', resetTimer);
        timeLimitInput.addEventListener('change', resetTimer);

        // Keyboard Navigation
        document.addEventListener('keydown', (e) => {
            if (messageBoxOverlay.style.display === 'block') { // Do not allow keyboard navigation if message box is open
                return;
            }

            const originalQuestionIndex = currentQuizOrder[currentQuestionIndex];
            const currentQuestionState = questionStates[originalQuestionIndex];
            const hasBeenChecked = currentQuestionState.status !== 'unanswered';
            const hasAnswered = currentQuestionState.userAnswer !== null;

            switch (e.key) {
                case 'ArrowLeft':
                    navigate('prev');
                    break;
                case 'ArrowRight':
                    navigate('next');
                    break;
                case '1':
                case '2':
                case '3':
                case '4':
                    if (!hasBeenChecked && !isTimerFinished()) {
                        const optionButtons = optionsContainerElem.querySelectorAll('.option-button');
                        if (optionButtons[parseInt(e.key) - 1]) {
                            optionButtons[parseInt(e.key) - 1].click();
                        }
                    }
                    break;
                case 'a':
                case 'A':
                case 'b':
                case 'B':
                case 'c':
                case 'C':
                case 'd':
                case 'D':
                     if (!hasBeenChecked && !isTimerFinished()) {
                        const optionIndex = e.key.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0);
                        const optionButtons = optionsContainerElem.querySelectorAll('.option-button');
                        if (optionButtons[optionIndex]) {
                            optionButtons[optionIndex].click();
                        }
                    }
                    break;
                case 'Enter':
                    if (studyModeToggle.checked && hasAnswered && !hasBeenChecked && !isTimerFinished()) {
                        checkAnswer();
                    } else if (!studyModeToggle.checked && !checkAnswerBtn.disabled) {
                        checkAnswer();
                    } else if (nextBtn.disabled === false && (hasBeenChecked || isTimerFinished())) { // If checked/timer finished and can go next
                        navigate('next');
                    }
                    break;
            }
        });


        // Initialize quiz on page load
        window.onload = () => {
            initializeQuizOrder(); // Initialize question order
            createQuestionNavigation();
            resetTimer(); // Initialize timer
            displayQuestion();
        };

    </script>
</body>
</html>

