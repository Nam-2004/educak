<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ôn Thi Big Data Nâng Cao</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .quiz-container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .header-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }
        .timer-progress-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px 15px;
            background-color: #e0f2fe;
            border-radius: 8px;
            border: 1px solid #90cdf4;
            color: #0c4a6e;
            font-weight: 600;
        }
        .timer-display {
            font-size: 1.2rem;
            text-align: center;
        }
        .timer-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 5px;
        }
        .timer-controls button {
            padding: 8px 15px;
            border-radius: 6px;
            background-color: #3b82f6;
            color: white;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .timer-controls button:hover {
            background-color: #2563eb;
        }
        .timer-controls button:disabled {
            background-color: #93c5fd;
            cursor: not-allowed;
        }
        .progress-bar-container {
            width: 100%;
            height: 10px;
            background-color: #e5e7eb;
            border-radius: 5px;
            overflow: hidden;
        }
        .progress-bar-fill {
            height: 100%;
            width: 0%;
            background-color: #4f46e5;
            border-radius: 5px;
            transition: width 0.3s ease-out;
        }

        .settings-toggles {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px 15px;
            background-color: #f9fafb;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .toggle-switch input[type="checkbox"] {
            position: relative;
            width: 40px;
            height: 24px;
            -webkit-appearance: none;
            background: #ccc;
            outline: none;
            border-radius: 20px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
            transition: 0.3s;
            cursor: pointer;
        }
        .toggle-switch input[type="checkbox"]:checked {
            background: #4f46e5;
        }
        .toggle-switch input[type="checkbox"]::before {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #fff;
            top: 4px;
            left: 4px;
            transition: 0.3s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .toggle-switch input[type="checkbox"]:checked::before {
            left: 20px;
        }
        .question-nav {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
            justify-content: center;
        }
        .question-nav-button {
            padding: 8px 12px;
            border-radius: 8px;
            background-color: #e0e7ff;
            color: #4f46e5;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            border: 1px solid #c7d2fe;
        }
        .question-nav-button:hover {
            background-color: #c7d2fe;
            transform: translateY(-1px);
        }
        .question-nav-button.active {
            background-color: #4f46e5;
            color: #ffffff;
            border-color: #4f46e5;
        }
        .question-nav-button.answered-correctly {
            background-color: #d1fae5; /* Green for correct */
            color: #065f46;
            border-color: #6ee7b7;
        }
        .question-nav-button.answered-incorrectly {
            background-color: #fee2e2; /* Red for incorrect */
            color: #991b1b;
            border-color: #fca5a5;
        }
        .question-nav-button.marked-for-review {
            background-color: #fffbeb; /* Yellow for marked */
            color: #92400e;
            border-color: #fcd34d;
        }


        .question-box {
            background-color: #f9fafb;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #e5e7eb;
        }
        .question-text {
            font-size: 1.25rem; /* 20px */
            font-weight: 600;
            margin-bottom: 20px;
            color: #1f2937;
        }
        .options-grid {
            display: grid;
            gap: 12px;
        }
        .option-button {
            width: 100%;
            padding: 12px 15px;
            border-radius: 8px;
            border: 2px solid #d1d5db;
            background-color: #ffffff;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-size: 1rem;
            color: #374151;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }
        .option-button:hover:not(.selected):not(.correct):not(.incorrect):not(.disabled) {
            background-color: #eff6ff;
            border-color: #93c5fd;
        }
        .option-button.selected {
            background-color: #bfdbfe;
            border-color: #3b82f6;
            font-weight: 500;
            color: #1e40af;
        }
        .option-button.correct {
            background-color: #d1fae5;
            border-color: #34d399;
            font-weight: 500;
            color: #065f46;
        }
        .option-button.incorrect {
            background-color: #fee2e2;
            border-color: #ef4444;
            font-weight: 500;
            color: #991b1b;
        }
        .option-button.disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }
        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            gap: 10px;
        }
        .nav-button {
            padding: 12px 25px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .nav-button.prev {
            background-color: #6b7280;
            color: #ffffff;
        }
        .nav-button.prev:hover {
            background-color: #4b5563;
            transform: translateY(-1px);
        }
        .nav-button.next, .nav-button.check, .nav-button.mark-for-review, .nav-button.reset-quiz {
            background-color: #4f46e5;
            color: #ffffff;
        }
        .nav-button.next:hover, .nav-button.check:hover, .nav-button.mark-for-review:hover, .nav-button.reset-quiz:hover {
            background-color: #4338ca;
            transform: translateY(-1px);
        }
        .nav-button:disabled {
            background-color: #d1d5db;
            color: #9ca3af;
            cursor: not-allowed;
            box-shadow: none;
        }
        .score-display {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1f2937;
            text-align: center;
            margin-top: 15px;
            padding: 10px;
            background-color: #e0f2fe;
            border-radius: 8px;
            border: 1px solid #90cdf4;
        }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 15px;
            text-align: center;
            max-width: 350px;
            width: 90%;
        }
        .message-box-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
            display: none; /* Hidden by default */
        }
        .message-box-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1f2937;
        }
        .message-box-content {
            font-size: 1rem;
            color: #374151;
        }
        .message-box-button {
            padding: 10px 20px;
            background-color: #4f46e5;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        .message-box-button:hover {
            background-color: #4338ca;
        }

        .quiz-summary {
            background-color: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            margin-top: 20px;
            display: none; /* Hidden by default */
        }
        .quiz-summary h2 {
            font-size: 1.75rem; /* 28px */
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 20px;
            text-align: center;
        }
        .incorrect-question-item, .marked-question-item {
            background-color: #fef2f2;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #fecaca;
            margin-bottom: 15px;
        }
        .marked-question-item {
            background-color: #fffbeb;
            border-color: #fcd34d;
        }
        .incorrect-question-item p, .marked-question-item p {
            margin-bottom: 8px;
            line-height: 1.5;
        }
        .incorrect-question-item .question-text-summary, .marked-question-item .question-text-summary {
            font-weight: 600;
            color: #991b1b;
        }
        .marked-question-item .question-text-summary {
            color: #92400e;
        }
        .incorrect-question-item .correct-answer-summary, .marked-question-item .correct-answer-summary {
            font-weight: 600;
            color: #065f46;
        }
        .incorrect-question-item .hint-summary, .marked-question-item .hint-summary {
            font-style: italic;
            color: #4b5563;
            font-size: 0.95rem;
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px dashed #e5e7eb;
        }
        .summary-section-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin-top: 20px;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 2px solid #e5e7eb;
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            .quiz-container {
                padding: 20px;
            }
            .question-text {
                font-size: 1.1rem;
            }
            .option-button {
                padding: 10px;
                font-size: 0.95rem;
            }
            .nav-button {
                padding: 10px 15px;
                font-size: 0.9rem;
            }
            .settings-toggles {
                padding: 8px 12px;
            }
            .toggle-switch label {
                font-size: 0.9rem;
            }
            .quiz-summary h2 {
                font-size: 1.5rem;
            }
            .incorrect-question-item p, .marked-question-item p {
                font-size: 0.95rem;
            }
            .incorrect-question-item .hint-summary, .marked-question-item .hint-summary {
                font-size: 0.9rem;
            }
            .timer-display {
                font-size: 1rem;
            }
            .timer-controls button {
                padding: 6px 10px;
                font-size: 0.85rem;
            }
        }
    </style>
</head>
<body>
    <div class="quiz-container">
        <h1 class="text-3xl font-bold text-center text-indigo-700 mb-6">Ôn Thi Big Data Nâng Cao</h1>

        <div class="header-section">
            <div class="timer-progress-section">
                <div class="flex items-center justify-between">
                    <label for="timeLimitInput" class="text-gray-700 font-medium mr-2">Thời gian:</label>
                    <input type="number" id="timeLimitInput" value="60" min="1" max="180" class="w-20 p-1 border rounded-md text-center text-sm"> phút
                </div>
                <div id="timerDisplay" class="timer-display">00:00</div>
                <div class="timer-controls">
                    <button id="startTimerBtn">Bắt đầu</button>
                    <button id="pauseTimerBtn" disabled>Tạm dừng</button>
                    <button id="resetTimerBtn">Đặt lại</button>
                </div>
                <div class="progress-bar-container">
                    <div id="progressBarFill" class="progress-bar-fill"></div>
                </div>
            </div>

            <div class="settings-toggles">
                <div class="toggle-switch">
                    <input type="checkbox" id="shuffleQuestionsOrder" checked>
                    <label for="shuffleQuestionsOrder" class="text-gray-700 font-medium">Đảo thứ tự câu hỏi</label>
                </div>
                <div class="toggle-switch">
                    <input type="checkbox" id="shuffleAnswers" checked>
                    <label for="shuffleAnswers" class="text-gray-700 font-medium">Đảo thứ tự đáp án</label>
                </div>
                <div class="toggle-switch">
                    <input type="checkbox" id="studyModeToggle">
                    <label for="studyModeToggle" class="text-gray-700 font-medium">Chế độ học (Kiểm tra ngay)</label>
                </div>
            </div>
        </div>

        <div class="question-nav" id="questionNav">
            <!-- Các nút điều hướng câu hỏi sẽ được tạo tự động tại đây -->
        </div>

        <div class="question-box">
            <div id="questionNumber" class="text-lg font-semibold text-gray-600 mb-2"></div>
            <div id="questionText" class="question-text"></div>
            <div id="optionsContainer" class="options-grid">
                <!-- Các lựa chọn đáp án sẽ được tạo tự động tại đây -->
            </div>
        </div>

        <div class="navigation-buttons">
            <button id="prevBtn" class="nav-button prev">Câu trước (←)</button>
            <button id="markForReviewBtn" class="nav-button mark-for-review">Đánh dấu xem lại</button>
            <button id="checkAnswerBtn" class="nav-button check">Kiểm tra đáp án (Enter)</button>
            <button id="nextBtn" class="nav-button next">Câu tiếp theo (→)</button>
        </div>

        <div id="scoreDisplay" class="score-display hidden"></div>
        <button id="resetQuizBtn" class="nav-button reset-quiz mt-4 hidden">Làm lại bài thi</button>

        <!-- Quiz Summary Section -->
        <div id="quizSummary" class="quiz-summary hidden">
            <h2>Tổng kết bài thi</h2>
            <h3 class="summary-section-title">Các câu hỏi làm sai</h3>
            <div id="incorrectQuestionsList">
                <!-- Incorrect questions will be listed here -->
            </div>
            <h3 class="summary-section-title">Các câu hỏi đã đánh dấu xem lại</h3>
            <div id="markedQuestionsList">
                <!-- Marked for review questions will be listed here -->
            </div>
        </div>

        <!-- Message Box -->
        <div class="message-box-overlay" id="messageBoxOverlay"></div>
        <div class="message-box" id="messageBox">
            <div class="message-box-title" id="messageBoxTitle"></div>
            <div class="message-box-content" id="messageBoxContent"></div>
            <button class="message-box-button" id="messageBoxButton">Đóng</button>
        </div>

    </div>

    <script>
        // Dữ liệu câu hỏi được trích xuất từ file PDF về Big Data
        const quizData = [
            {
                question: "Dữ liệu của Big Data là loại nào ?",
                options: [
                    "Structured Data",
                    "Semi-Structured Data",
                    "Unstructured Data",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Big Data bao gồm cả dữ liệu có cấu trúc, bán cấu trúc và phi cấu trúc."
            },
            {
                question: "Đặc trưng nào không phải của Big Data",
                options: [
                    "Volume",
                    "Variety",
                    "Vision",
                    "Velocity"
                ],
                answer: "C",
                hint: "Các đặc trưng của Big Data thường được biết đến là 3Vs (Volume, Variety, Velocity), đôi khi mở rộng thành 5Vs (thêm Veracity, Value). Vision không phải là đặc trưng."
            },
            {
                question: "NoSQL là ?",
                options: [
                    "Database",
                    "Field",
                    "Document",
                    "Collection"
                ],
                answer: "A",
                hint: "NoSQL là một loại cơ sở dữ liệu (Database) không theo mô hình quan hệ truyền thống."
            },
            {
                question: "Mục tiêu của NoSQL là gì?",
                options: [
                    "NoSQL cung cấp một giải pháp thay thế cho cơ sở dữ liệu SQL để lưu trữ dữ liệu dạng văn bản.",
                    "Cơ sở dữ liệu NoSQL cho phép lưu trữ dữ liệu không có cấu trúc.",
                    "NoSQL không thích hợp để lưu trữ dữ liệu có cấu trúc.",
                    "NoSQL là một định dạng dữ liệu mới để lưu trữ các tập dữ liệu lớn."
                ],
                answer: "B",
                hint: "Mục tiêu chính của NoSQL là hỗ trợ lưu trữ và xử lý dữ liệu không có cấu trúc hoặc bán cấu trúc."
            },
            {
                question: "Cloudera phát triển công cụ nào ?",
                options: [
                    "HCatalog",
                    "Hbase",
                    "Imphala",
                    "Oozie"
                ],
                answer: "B",
                hint: "Cloudera là một trong những nhà phát triển chính của Apache HBase, một CSDL NoSQL phân tán."
            },
            {
                question: "Loại nào không phải là CSDL NoSQL ?",
                options: [
                    "SQL Server",
                    "MongoDB",
                    "Cassandra",
                    "Không có"
                ],
                answer: "A",
                hint: "SQL Server là một hệ quản trị cơ sở dữ liệu quan hệ (RDBMS), không phải NoSQL."
            },
            {
                question: "Đâu là một kiểu của CSDL NoSQL",
                options: [
                    "SQL",
                    "Document databases",
                    "JSON",
                    "Tất cả"
                ],
                answer: "B",
                hint: "Document databases (cơ sở dữ liệu tài liệu) là một trong các kiểu của NoSQL."
            },
            {
                question: "Chọn đúng 5 đặc trưng cho Big Data ?",
                options: [
                    "Volume, Velocity, Variety, Veracity, Value",
                    "Volume, Videos, Velocity, Variability, Value",
                    "Volume, Variability, Veracity, Visualization, Value",
                    "Volume, Velocity, Veracity, Visualization, Value"
                ],
                answer: "A",
                hint: "5Vs phổ biến của Big Data là Volume (khối lượng), Velocity (tốc độ), Variety (đa dạng), Veracity (tính xác thực) và Value (giá trị)."
            },
            {
                question: "Velocity (Tốc độ) là đặc trưng nói về?",
                options: [
                    "Tốc độ gia tăng khối lượng dữ liệu lớn",
                    "Tốc độ cập nhật dữ liệu lớn",
                    "Tốc độ xử lý dữ liệu lớn",
                    "Tốc độ lưu trữ dữ liệu lớn"
                ],
                answer: "A",
                hint: "Velocity trong Big Data đề cập đến tốc độ tạo ra, thu thập và xử lý dữ liệu."
            },
            {
                question: "Variety (Tính đa dạng) là đặc trưng về ?",
                options: [
                    "Kiêu dữ liệu thu thập",
                    "Kiểu nội dung dữ liệu",
                    "Nguồn thu thập dữ liệu",
                    "Phương thức xử lý dữ liệu"
                ],
                answer: "A",
                hint: "Variety đề cập đến các dạng và nguồn dữ liệu khác nhau (có cấu trúc, bán cấu trúc, phi cấu trúc)."
            },
            {
                question: "Đặc trưng quan trọng nhất của Big Data?",
                options: [
                    "Khối lượng",
                    "Tính đa dạng",
                    "Tốc độ",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Không có một đặc trưng nào là quan trọng nhất tuyệt đối; tất cả các đặc trưng (Volume, Variety, Velocity) đều quan trọng trong việc định nghĩa Big Data."
            },
            {
                question: "Đâu là đặc trưng quyết định việc triển khai Dữ liệu lớn? (Câu 12)",
                options: [
                    "Khối lượng",
                    "Giá trị",
                    "Tốc Độ",
                    "Tính đa dạng"
                ],
                answer: "B",
                hint: "Value (Giá trị) là đặc trưng quyết định việc triển khai Big Data vì mục tiêu cuối cùng là tạo ra giá trị từ dữ liệu."
            },
            {
                question: "Tích hợp dữ liệu là quá trình ?",
                options: [
                    "Kết hợp các dữ liệu không đồng nhất từ nhiều nguồn khác nhau",
                    "Sao chép dữ liệu vào CSDL hệ thống để tiến hành phân tích",
                    "Làm sạch các dữ liệu thu thập được từ các hệ thống thành phần",
                    "Tăng giá trị từ các tài nguyên dữ liệu đang lưu trữ phân tán"
                ],
                answer: "A",
                hint: "Tích hợp dữ liệu là việc kết hợp dữ liệu từ các nguồn khác nhau thành một cái nhìn thống nhất."
            },
            {
                question: "Thuật ngữ Dữ liệu lớn ra đời năm nào?",
                options: [
                    "1997",
                    "2000",
                    "1998",
                    "1941"
                ],
                answer: "A",
                hint: "Thuật ngữ 'Big Data' được đặt ra vào năm 1997 bởi John Mashey."
            },
            {
                question: "Các dạng thức khoa học dữ liệu của Jim Gray?",
                options: [
                    "Thực nghiệm",
                    "Lý thuyết",
                    "Tính toán",
                    "Tất cả các ý"
                ],
                answer: "D",
                hint: "Jim Gray đã mô tả bốn dạng thức khoa học: Thực nghiệm, Lý thuyết, Tính toán, và Dựa trên dữ liệu (Data-driven)."
            },
            {
                question: "Phát biểu nào không phải dạng thức nghiên cứu Khoa học dữ liệu của Jim Gray?",
                options: [
                    "Khai thác dữ liệu",
                    "Mô phỏng",
                    "Tính toán",
                    "Thực nghiệm"
                ],
                answer: "A",
                hint: "Khai thác dữ liệu là một kỹ thuật, không phải dạng thức nghiên cứu cơ bản theo Jim Gray."
            },
            {
                question: "Đâu không phải là phương thức xử lý dữ liệu lớn?",
                options: [
                    "Thu thập (acquire)",
                    "Đánh giá (reviews)",
                    "Tổ chức (organize)",
                    "Phân tích (analyze)"
                ],
                answer: "B",
                hint: "Các phương thức xử lý dữ liệu lớn bao gồm Thu thập, Tổ chức, Phân tích, nhưng 'Đánh giá' không phải là một giai đoạn xử lý chính."
            },
            {
                question: "RDBMS là gì ?",
                options: [
                    "Relational Database Management System",
                    "Relat Data Management System",
                    "Relational Database Microsoft System",
                    "Tất cả"
                ],
                answer: "A",
                hint: "RDBMS là viết tắt của Relational Database Management System (Hệ quản trị cơ sở dữ liệu quan hệ)."
            },
            {
                question: "Thị trường Big Data bao gồm:",
                options: [
                    "Phần cứng",
                    "Phần Mềm",
                    "Tất cả",
                    "Dịch vụ"
                ],
                answer: "C",
                hint: "Thị trường Big Data bao gồm Phần cứng, Phần mềm và Dịch vụ."
            },
            {
                question: "Nhược điểm của tích hợp dữ liệu theo phương pháp Tight Coupling",
                options: [
                    "Độ trễ",
                    "Phản hồi truy vấn",
                    "Phụ thuộc vào nguồn dữ liệu",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Tight Coupling (liên kết chặt) trong tích hợp dữ liệu có nhược điểm về độ trễ, phản hồi truy vấn và sự phụ thuộc vào nguồn dữ liệu."
            },
            {
                question: "Nhược điểm của tích hợp dữ liệu theo phương pháp Loose Coupling (Câu 21)",
                options: [
                    "Tất cả",
                    "Chi phí cao",
                    "Độ trễ",
                    "Phụ thuộc mạng / băng thông"
                ],
                answer: "D",
                hint: "Loose Coupling (liên kết lỏng) có nhược điểm về sự phụ thuộc vào mạng/băng thông và có thể có độ trễ."
            },
            {
                question: "Công cụ nào hỗ trợ tốt NoSQL?",
                options: [
                    "SAP Data Services",
                    "Oracle Data Integrator",
                    "SQL Server Integration Services",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Các công cụ tích hợp dữ liệu hiện đại như SAP Data Services, Oracle Data Integrator, SQL Server Integration Services đều có khả năng hỗ trợ NoSQL."
            },
            {
                question: "Công cụ tích hợp dữ liệu Boomi là của?",
                options: [
                    "Dell",
                    "IBM",
                    "Microsoft",
                    "SAP"
                ],
                answer: "A",
                hint: "Dell Boomi là một nền tảng tích hợp dữ liệu thuộc sở hữu của Dell."
            },
            {
                question: "Công cụ SQL Server Integrator do ai phát triển ?",
                options: [
                    "Oracle",
                    "IBM",
                    "Microsoft",
                    "SAP"
                ],
                answer: "C",
                hint: "SQL Server Integration Services (SSIS) là một phần của Microsoft SQL Server."
            },
            {
                question: "SAP Data Service là công cụ để làm gì ?",
                options: [
                    "Lưu trữ dữ liệu",
                    "Tích hợp dữ liệu",
                    "Phân tích dữ liệu",
                    "Tất cả"
                ],
                answer: "B",
                hint: "SAP Data Services là một công cụ mạnh mẽ cho việc tích hợp dữ liệu (ETL)."
            },
            {
                question: "Hệ quản trị CSLD DynamoDB là kiểu nào ?",
                options: [
                    "Key value",
                    "Wide Column based",
                    "Document based",
                    "Graph based"
                ],
                answer: "A",
                hint: "Amazon DynamoDB là một cơ sở dữ liệu NoSQL kiểu Key-Value và Document."
            },
            {
                question: "Hệ quản trị CSLD MongoDB là kiểu nào ?",
                options: [
                    "Document based",
                    "Key value",
                    "Wide Column based",
                    "Graph based"
                ],
                answer: "A",
                hint: "MongoDB là cơ sở dữ liệu NoSQL phổ biến thuộc kiểu Document-based."
            },
            {
                question: "Hệ quản trị CSLD Neo4J là kiểu nào ?",
                options: [
                    "Key value",
                    "Wide Column based",
                    "Document based",
                    "Graph based"
                ],
                answer: "D",
                hint: "Neo4j là cơ sở dữ liệu NoSQL hàng đầu thuộc kiểu Graph-based (cơ sở dữ liệu đồ thị)."
            },
            {
                question: "Hệ quản trị CSLD IBM Graph là kiểu nào ?",
                options: [
                    "Key value",
                    "Document based",
                    "Graph based",
                    "Wide Column based"
                ],
                answer: "C",
                hint: "IBM Graph là một dịch vụ cơ sở dữ liệu đồ thị."
            },
            {
                question: "Hệ quản trị CSLD Google Big Table là kiểu nào ?",
                options: [
                    "Key value",
                    "Wide Column based",
                    "Document based",
                    "Graph based"
                ],
                answer: "B",
                hint: "Google Bigtable là cơ sở dữ liệu NoSQL kiểu Wide-Column Store."
            },
            {
                question: "Đâu không phải là RDBMS ? (Câu 31)",
                options: [
                    "IBM DB2",
                    "MS SQL Server",
                    "MS Access",
                    "Cassandra"
                ],
                answer: "D",
                hint: "Cassandra là một cơ sở dữ liệu NoSQL (Wide-column store), không phải RDBMS."
            },
            {
                question: "Loại nào là dữ liệu Bán cấu trúc ?",
                options: [
                    "Tất cả",
                    "JSON",
                    "CSV",
                    "XML"
                ],
                answer: "A",
                hint: "JSON, CSV, XML đều là các định dạng dữ liệu bán cấu trúc."
            },
            {
                question: "Loại nào là dữ liệu Unstructured ?",
                options: [
                    "Video",
                    "XML",
                    "Table",
                    "Tất cả"
                ],
                answer: "A",
                hint: "Video là một ví dụ điển hình của dữ liệu phi cấu trúc."
            },
            {
                question: "Yếu tố nào quyết định để sử dụng NoSQL",
                options: [
                    "Tốc độ gia tăng CSDL",
                    "Tính đa dạng của dữ liệu",
                    "Tốc độ truy cập dữ liệu",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Tất cả các yếu tố (tốc độ gia tăng dữ liệu, tính đa dạng, tốc độ truy cập) đều ảnh hưởng đến quyết định sử dụng NoSQL."
            },
            {
                question: "CSDL nào không phải kiểu Key-Value:",
                options: [
                    "MongoDB",
                    "DynamoDB",
                    "Redis",
                    "Riak"
                ],
                answer: "A",
                hint: "MongoDB là cơ sở dữ liệu tài liệu (Document-based), không phải Key-Value."
            },
            {
                question: "CSDL nào không phải kiểu Document:",
                options: [
                    "MongoDB",
                    "CouchDB",
                    "Elasticsearch",
                    "Riak"
                ],
                answer: "D",
                hint: "Riak là cơ sở dữ liệu Key-Value, không phải Document-based."
            },
            {
                question: "CSDL nào không phải kiểu Graph:",
                options: [
                    "InfoGrid",
                    "Hbase",
                    "InfiniteGraph",
                    "IBM Graph"
                ],
                answer: "B",
                hint: "HBase là cơ sở dữ liệu Wide-column, không phải Graph."
            },
            {
                question: "CSDL nào không phải kiểu Wide-Column:",
                options: [
                    "Hbase",
                    "Cassandra",
                    "BigTable",
                    "Dex"
                ],
                answer: "D",
                hint: "Dex là một cơ sở dữ liệu đồ thị (Graph database), không phải Wide-column."
            },
            {
                question: "Ưu điểm của hệ thống HDFS là gì ? (Câu 39)",
                options: [
                    "Lưu trữ phân tán, xử lý song song, khả năng chịu lỗi cao",
                    "Lưu trữ song song, xử lý phân tán, tính sẵn sàng cao",
                    "Xử lý phân tán song song, khả năng chịu lỗi chấp nhận sai sót",
                    "Tất cả"
                ],
                answer: "A",
                hint: "HDFS được thiết kế để lưu trữ phân tán, xử lý song song và có khả năng chịu lỗi."
            },
            {
                question: "Ưu điểm của DFS là gì ? (Câu 40)",
                options: [
                    "Hệ thống lưu trữ song song nên tránh được ảnh hưởng khi một máy chủ hoặc bộ nhớ bị lỗi",
                    "Hệ thống được sao lưu tại Server thứ hai nên đảm bảo việc cung cấp dữ liệu",
                    "Khi một máy chủ hoặc bộ nhớ bị lỗi, hệ thống tệp phân tán vẫn đảm bảo có thể cung cấp dữ liệu ổn định",
                    "Tất cả"
                ],
                answer: "C",
                hint: "Ưu điểm chính của Hệ thống tệp phân tán (DFS) là khả năng chịu lỗi và cung cấp dữ liệu ổn định."
            },
            {
                question: "Ưu điểm của công nghệ Cluster (Câu 41)",
                options: [
                    "Tất cả",
                    "Hiệu quả chi phí",
                    "Tính sẵn sàng cao",
                    "Khả năng mở rộng linh hoạt"
                ],
                answer: "A",
                hint: "Công nghệ Cluster mang lại hiệu quả chi phí, tính sẵn sàng cao và khả năng mở rộng linh hoạt."
            },
            {
                question: "Cluster node có mấy loại ? (Câu 42)",
                options: [
                    "1",
                    "2",
                    "3",
                    "4"
                ],
                answer: "B",
                hint: "Trong kiến trúc Hadoop, có hai loại node chính là NameNode (Master) và DataNode (Slave)."
            },
            {
                question: "Nguồn của kiến trúc HDFS trong Hadoop có nguồn gốc là (Câu 43)",
                options: [
                    "Hệ thống tệp phân phối của Google",
                    "Hệ thống tệp phân tán của Yahoo",
                    "Hệ thống tệp phân tán của Facebook",
                    "Hệ thống tệp phân tán Azure"
                ],
                answer: "A",
                hint: "HDFS được lấy cảm hứng từ Google File System (GFS)."
            },
            {
                question: "Loại dữ liệu mà Hadoop có thể xử lý là (Câu 44)",
                options: [
                    "Structred (Có cấu trúc)",
                    "Semi-structured (Bán cấu trúc)",
                    "Unstructured (Không có cấu trúc)",
                    "All of the above (Tất cả những điều trên)"
                ],
                answer: "D",
                hint: "Hadoop có khả năng xử lý tất cả các loại dữ liệu: có cấu trúc, bán cấu trúc và phi cấu trúc."
            },
            {
                question: "YARN là viết tắt của (Câu 45)",
                options: [
                    "Yahoo's another resource name",
                    "Yet another resource negotiator",
                    "Yahoo's archived Resource names",
                    "Yet another resource need."
                ],
                answer: "B",
                hint: "YARN là viết tắt của Yet Another Resource Negotiator."
            },
            {
                question: "Điều nào sau đây không phải là mục tiêu của HDFS? (Câu 46)",
                options: [
                    "Phát hiện lỗi và khôi phục",
                    "Xử lý tập dữ liệu khổng lồ",
                    "Ngăn chặn việc xóa dữ liệu",
                    "Cung cấp băng thông mạng cao để di chuyển dữ liệu"
                ],
                answer: "C",
                hint: "HDFS không có mục tiêu 'Ngăn chặn việc xóa dữ liệu'. Nó tập trung vào khả năng chịu lỗi, xử lý dữ liệu lớn và băng thông cao."
            },
            {
                question: "Trong HDFS, các tệp không thể (Câu 47)",
                options: [
                    "Đọc",
                    "Xóa",
                    "Thực thi",
                    "Lưu trữ"
                ],
                answer: "C",
                hint: "Trong HDFS, các tệp không thể trực tiếp 'Thực thi'."
            },
            {
                question: "So với RDBMS, Hadoop (Câu 48)",
                options: [
                    "Có tính toàn vẹn dữ liệu cao hơn.",
                    "Có giao dịch ACID không",
                    "Thích hợp để đọc và truy vấn nhanh",
                    "Hoạt động tốt hơn trên dữ liệu phi cấu trúc và bán cấu trúc."
                ],
                answer: "D",
                hint: "Hadoop vượt trội trong việc xử lý dữ liệu phi cấu trúc và bán cấu trúc so với RDBMS."
            },
            {
                question: "Vấn đề chính gặp phải khi đọc và ghi dữ liệu song song từ nhiều đĩa là gì? (Câu 49)",
                options: [
                    "Xử lý khối lượng lớn dữ liệu nhanh hơn.",
                    "Kết hợp dữ liệu từ nhiều đĩa.",
                    "Phần mềm cần thiết để thực hiện nhiệm vụ này là cực kỳ tốn kém.",
                    "Phần cứng cần thiết để thực hiện tác vụ này là cực kỳ tốn kém."
                ],
                answer: "B",
                hint: "Thách thức chính là kết hợp và đồng bộ hóa dữ liệu từ nhiều nguồn khác nhau."
            },
            {
                question: "Tính năng định vị dữ liệu trong Hadoop có nghĩa là (Câu 50)",
                options: [
                    "lưu trữ cùng một dữ liệu trên nhiều nút.",
                    "chuyên vị trí dữ liệu từ nút này sang nút khác.",
                    "đồng định vị dữ liệu với các nút tính toán.",
                    "Phân phối dữ liệu trên nhiều nút."
                ],
                answer: "C",
                hint: "Data locality (định vị dữ liệu) trong Hadoop có nghĩa là chuyển quá trình tính toán đến nơi dữ liệu được lưu trữ."
            },
            {
                question: "Các tệp HDFS được thiết kế cho (Câu 51)",
                options: [
                    "Nhiều người viết và sửa đổi ở các hiệu số tùy ý.",
                    "Chỉ nối vào cuối tệp.",
                    "Chỉ ghi thành tệp một lần.",
                    "Truy cập dữ liệu có độ trễ thấp."
                ],
                answer: "C",
                hint: "HDFS được tối ưu cho mô hình 'ghi một lần, đọc nhiều lần' (write-once, read-many)."
            },
            {
                question: "Hệ thống Apache Hadoop được viết bằng ngôn ngữ nào? (Câu 52)",
                options: [
                    "C ++",
                    "Python",
                    "Java",
                    "Go"
                ],
                answer: "C",
                hint: "Apache Hadoop chủ yếu được viết bằng Java."
            },
            {
                question: "Cái nào không phải là một trong đặc trưng 3Vs của dữ liệu lớn? (Câu 53)",
                options: [
                    "Vận tốc - Velocity",
                    "Tính xác thực - Veracity",
                    "Khối lượng - Volume",
                    "Đa dạng - Variety"
                ],
                answer: "B",
                hint: "Tính xác thực (Veracity) là một trong 5Vs, nhưng không phải là một trong 3Vs gốc."
            },
            {
                question: "Điều nào sau đây đúng đối với Hadoop? (Câu 54)",
                options: [
                    "Đây là một khung phân tán.",
                    "Thuật toán chính được sử dụng trong đó là Map Reduce.",
                    "Nó chạy có thể thực thi trên hạ tầng Cloud Computing.",
                    "Tất cả đều đúng"
                ],
                answer: "D",
                hint: "Tất cả các phát biểu trên đều đúng về Hadoop."
            },
            {
                question: "Loại nào sau đây lưu trữ dữ liệu? (Câu 55)",
                options: [
                    "Name node",
                    "Data node",
                    "Master node",
                    "Không có"
                ],
                answer: "B",
                hint: "DataNode là nơi lưu trữ dữ liệu thực tế trong HDFS."
            },
            {
                question: "Node nào sau đây quản lý các nút khác? (Câu 56)",
                options: [
                    "Name node",
                    "Data node",
                    "Slave node",
                    "Tất cả"
                ],
                answer: "A",
                hint: "NameNode là Master node, quản lý không gian tên tệp và điều phối các DataNode."
            },
            {
                question: "Hadoop xử lý khối lượng lớn dữ liệu như thế nào? (Câu 57)",
                options: [
                    "Hadoop sử dụng song song rất nhiều máy. Điều này tối ưu hóa việc xử lý dữ liệu.",
                    "Hadoop được thiết kế đặc biệt để xử lý lượng lớn dữ liệu bằng cách tận dụng phần cứng MPP.",
                    "Hadoop gửi mã đến dữ liệu thay vì gửi dữ liệu đến mã.",
                    "Hadoop sử dụng các kỹ thuật bộ nhớ đệm phức tạp trên NameNode để tăng tốc độ xử lý dữ liệu."
                ],
                answer: "C",
                hint: "Hadoop áp dụng nguyên tắc 'data locality': di chuyển logic xử lý (mã) đến gần dữ liệu thay vì di chuyển dữ liệu."
            },
            {
                question: "MapReduce do công ty nào phát triển ? (Câu 58)",
                options: [
                    "Apache",
                    "Google",
                    "IBM",
                    "Amazon"
                ],
                answer: "B",
                hint: "MapReduce được phát triển bởi Google."
            },
            {
                question: "Dịch vụ đám mây nào hỗ trợ tốt cho Big Data ? (Câu 59)",
                options: [
                    "Amazon AWS",
                    "Google Cloud",
                    "Tất cả",
                    "Microsoft Azure"
                ],
                answer: "C",
                hint: "Tất cả các nhà cung cấp đám mây lớn như AWS, Google Cloud, Azure đều có các dịch vụ hỗ trợ Big Data mạnh mẽ."
            },
            {
                question: "Nhược điểm khi triển khai Big Data trên nền tảng Cloud Computing là? (Câu 60)",
                options: [
                    "Nhiều rủi ro cho hệ thống",
                    "Không có ý đúng",
                    "Tốc độ xử lý không đảm bảo",
                    "Phân tích theo thời gian thực kém"
                ],
                answer: "A",
                hint: "Triển khai trên đám mây có thể tiềm ẩn rủi ro về bảo mật và kiểm soát dữ liệu nếu không được quản lý đúng cách."
            },
            {
                question: "Mô hình Điện toán đám mây IaaS ? (Câu 61)",
                options: [
                    "Cơ sở hạ tầng dưới dạng dịch vụ",
                    "Nền tảng dưới dạng dịch vụ",
                    "Phần mềm dưới dạng dịch vụ",
                    "Internet dưới dạng dịch vụ"
                ],
                answer: "A",
                hint: "IaaS là viết tắt của Infrastructure as a Service."
            },
            {
                question: "Mô hình Điện toán đám mây PaaS ? (Câu 62)",
                options: [
                    "Cơ sở hạ tầng dưới dạng dịch vụ",
                    "Nền tảng dưới dạng dịch vụ",
                    "Phần mềm dưới dạng dịch vụ",
                    "Internet dưới dạng dịch vụ"
                ],
                answer: "B",
                hint: "PaaS là viết tắt của Platform as a Service."
            },
            {
                question: "Mô hình Điện toán đám mây SaaS ? (Câu 63)",
                options: [
                    "Cơ sở hạ tầng dưới dạng dịch vụ",
                    "Nền tảng dưới dạng dịch vụ",
                    "Phần mềm dưới dạng dịch vụ",
                    "Internet dưới dạng dịch vụ"
                ],
                answer: "C",
                hint: "SaaS là viết tắt của Software as a Service."
            },
            {
                question: "Lợi ích của Cloud Computing với Big Data là ? (Câu 64)",
                options: [
                    "Triển khai hạ tầng nhanh chóng",
                    "Phân tích theo thời gian thực",
                    "Tối ưu chi phí duy trì hoạt động",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Điện toán đám mây mang lại nhiều lợi ích cho Big Data, bao gồm triển khai nhanh, phân tích thời gian thực và tối ưu chi phí."
            },
            {
                question: "Lợi ích vượt trội của Cloud Computing với Big Data là ? (Câu 65)",
                options: [
                    "Hạn chế đầu tư máy móc",
                    "Phân tích theo thời gian thực",
                    "Tối ưu chi phí duy trì hoạt động",
                    "Tất cả"
                ],
                answer: "A",
                hint: "Lợi ích vượt trội là giảm thiểu đầu tư ban đầu vào phần cứng."
            },
            {
                question: "Dịch vụ lưu trữ dữ của Amazon - AWS là? (Câu 66)",
                options: [
                    "Amazon S3",
                    "Amazon RDS",
                    "Amazon Lambda",
                    "EC2"
                ],
                answer: "A",
                hint: "Amazon S3 (Simple Storage Service) là dịch vụ lưu trữ đối tượng của AWS."
            },
            {
                question: "Dịch vụ lưu trữ của Microsoft Azure là ? (Câu 67)",
                options: [
                    "Virtual Machines",
                    "Azure Function",
                    "Azure Disk Storage",
                    "Azure Cosmos DB"
                ],
                answer: "C",
                hint: "Azure Disk Storage là dịch vụ lưu trữ đĩa của Azure."
            },
            {
                question: "Dịch vụ lưu trữ của Google Cloud Platfom là? (Câu 68)",
                options: [
                    "Google Driver",
                    "Goolge Functions",
                    "Google Cloud Storage",
                    "Google Cloud Datastore"
                ],
                answer: "C",
                hint: "Google Cloud Storage là dịch vụ lưu trữ đối tượng của Google Cloud."
            },
            {
                question: "Đám mây AWS cung cấp dịch vụ NoSQL Database (Câu 69)",
                options: [
                    "Amazon RDS",
                    "Amazon EC2",
                    "Amazon DynamoDB",
                    "Amazon Container Service"
                ],
                answer: "C",
                hint: "Amazon DynamoDB là dịch vụ cơ sở dữ liệu NoSQL của AWS."
            },
            {
                question: "Đám mây Microsoft Azure cung cấp dịch vụ NoSQL Database (Câu 70)",
                options: [
                    "Table Storage",
                    "SQL DB",
                    "Azure Functions",
                    "Cloud Service"
                ],
                answer: "A",
                hint: "Azure Table Storage là dịch vụ NoSQL key-value của Azure."
            },
            {
                question: "Dịch vụ tích hợp dữ liệu trên đám mây trên Google Cloud Platform (Câu 71)",
                options: [
                    "Google Cloud Dataprep",
                    "Google Cloud Data Fusion",
                    "Google Data Catalog",
                    "Google BigQuery"
                ],
                answer: "B",
                hint: "Google Cloud Data Fusion là dịch vụ tích hợp dữ liệu được quản lý hoàn toàn."
            },
            {
                question: "Dịch vụ thông minh giúp khái phá, làm sạch dữ liệu trên Google Cloud Platform (Câu 72)",
                options: [
                    "Goolge Functions",
                    "Google BigQuery",
                    "Google Cloud Dataprep",
                    "Google Data Catalog"
                ],
                answer: "C",
                hint: "Google Cloud Dataprep là dịch vụ giúp khám phá, làm sạch và chuẩn bị dữ liệu."
            },
            {
                question: "Trên Google Cloud Platform dịch vụ nào quản lý CSDL NoQuery (Câu 73)",
                options: [
                    "Google Cloud Dataprep",
                    "Google Data Catalog",
                    "Google BigQuery",
                    "Cloud Bigtable"
                ],
                answer: "D",
                hint: "Cloud Bigtable là dịch vụ NoSQL Wide-column của Google Cloud."
            },
            {
                question: "Trên Google Cloud Platform dịch vụ nào quản lý danh mục dữ liệu (Câu 74)",
                options: [
                    "Google Data Catalog",
                    "Google Cloud Dataprep",
                    "Google Data Catalog",
                    "Google BigQuery"
                ],
                answer: "A",
                hint: "Google Data Catalog là dịch vụ quản lý siêu dữ liệu và danh mục dữ liệu."
            },
            {
                question: "Trên Google Cloud Platform dịch vụ phân tích dữ liệu được cung cấp (Câu 75)",
                options: [
                    "Google Data Catalog",
                    "Google BigQuery",
                    "Google Cloud Dataprep",
                    "Goolge Functions"
                ],
                answer: "B",
                hint: "Google BigQuery là kho dữ liệu và dịch vụ phân tích dữ liệu lớn của Google Cloud."
            },
            {
                question: "Nền tảng Cloudera hỗ trợ hệ CSDL quan hệ nào? (Câu 76)",
                options: [
                    "MySQL",
                    "Oracle",
                    "PostgreSQL",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Cloudera hỗ trợ tích hợp với nhiều hệ quản trị CSDL quan hệ khác nhau."
            },
            {
                question: "Hệ CSDL NoSQL trên nền tảng Cloudera là ? (Câu 77)",
                options: [
                    "Apache Accumulo",
                    "DynamoDB",
                    "AppEngine Datastore",
                    "Table Storage"
                ],
                answer: "A",
                hint: "Apache Accumulo là một trong những CSDL NoSQL được hỗ trợ trên nền tảng Cloudera."
            },
            {
                question: "Dịch vụ phân tích dữ liệu lớn Cloudera cung cấp là? (Câu 78)",
                options: [
                    "Hadoop",
                    "BigQuery",
                    "Elastic MapReduce",
                    "Không có"
                ],
                answer: "A",
                hint: "Cloudera tập trung vào Hadoop để phân tích dữ liệu lớn."
            },
            {
                question: "Cloudera Enterprise có thể được triển khai trên đám mây nào (Câu 79)",
                options: [
                    "Google Cloud",
                    "Amazon AWS",
                    "Tất cả",
                    "Microsoft Azure"
                ],
                answer: "C",
                hint: "Cloudera Enterprise có thể triển khai trên nhiều nền tảng đám mây, bao gồm Google Cloud, AWS và Azure."
            },
            {
                question: "Công cụ trên Google Cloud Platform chuyển đổi dữ liệu hỗ trợ quyết định (Câu 80)",
                options: [
                    "Google Cloud",
                    "Google Data Catalog",
                    "Google Data Studio",
                    "Goolge Functions"
                ],
                answer: "C",
                hint: "Google Data Studio (nay là Looker Studio) là công cụ trực quan hóa và báo cáo dữ liệu."
            },
            {
                question: "Mô hình chính dành cho Điện toán đám mây ? (Câu 81)",
                options: [
                    "Cơ sở hạ tầng dưới dạng dịch vụ (IaaS)",
                    "Tất cả",
                    "Nền tảng dưới dạng dịch vụ (PaaS)",
                    "Phần mềm dưới dạng dịch vụ (SaaS)"
                ],
                answer: "B",
                hint: "Các mô hình chính của Điện toán đám mây bao gồm IaaS, PaaS và SaaS."
            },
            {
                question: "Kiểu phân tích dữ liệu nào cho ta biết điều gì đã xảy ra? (Câu 82)",
                options: [
                    "Descriptive Analysis",
                    "Diagnostic Analysis",
                    "Predictive Analysis",
                    "Prescriptive Analysis"
                ],
                answer: "A",
                hint: "Phân tích mô tả (Descriptive Analysis) giúp hiểu về những gì đã xảy ra trong quá khứ."
            },
            {
                question: "Kiểu phân tích dữ liệu nào chuẩn đoán lý do cho kết quả ? (Câu 83)",
                options: [
                    "Descriptive Analysis",
                    "Diagnostic Analysis",
                    "Predictive Analysis",
                    "Prescriptive Analysis"
                ],
                answer: "B",
                hint: "Phân tích chuẩn đoán (Diagnostic Analysis) tìm hiểu lý do tại sao một sự kiện xảy ra."
            },
            {
                question: "Kiểu phân tích dữ liệu nào dự đoán điều sẽ xảy ra ? (Câu 84)",
                options: [
                    "Descriptive Analysis",
                    "Diagnostic Analysis",
                    "Predictive Analysis",
                    "Prescriptive Analysis"
                ],
                answer: "C",
                hint: "Phân tích dự đoán (Predictive Analysis) tập trung vào việc dự đoán tương lai."
            },
            {
                question: "Kiểu phân tích nào để hỗ trợ đưa ra quyết định ? (Câu 85)",
                options: [
                    "Descriptive Analysis",
                    "Diagnostic Analysis",
                    "Predictive Analysis",
                    "Prescriptive Analysis"
                ],
                answer: "D",
                hint: "Phân tích đề xuất (Prescriptive Analysis) cung cấp các khuyến nghị để đưa ra quyết định tối ưu."
            },
            {
                question: "Loại phân tích dữ liệu nào kết quả thu được cho ta biết điều gì đã xảy ra ? (Câu 86)",
                options: [
                    "Phân tích mô tả",
                    "Phân tích chuẩn đoán",
                    "Phân tích dự đoán",
                    "Phân tích đề xuất"
                ],
                answer: "A",
                hint: "Phân tích mô tả trả lời câu hỏi 'điều gì đã xảy ra'."
            },
            {
                question: "Loại phân tích dữ liệu nào kết quả thu được cho ta biết tại sao điều đó xảy ra? (Câu 87)",
                options: [
                    "Phân tích mô tả",
                    "Phân tích chuẩn đoán",
                    "Phân tích dự đoán",
                    "Phân tích đề xuất"
                ],
                answer: "B",
                hint: "Phân tích chuẩn đoán trả lời câu hỏi 'tại sao điều đó xảy ra'."
            },
            {
                question: "Loại phân tích dữ liệu nào kết quả thu được cho ta biết điều gì sẽ xảy ra ? (Câu 88)",
                options: [
                    "Phân tích mô tả",
                    "Phân tích chuẩn đoán",
                    "Phân tích dự đoán",
                    "Phân tích đề xuất"
                ],
                answer: "C",
                hint: "Phân tích dự đoán trả lời câu hỏi 'điều gì sẽ xảy ra'."
            },
            {
                question: "Loại phân tích dữ liệu nào kết quả thu được cho ta biết làm thể nào để nó xảy ra (Câu 89)",
                options: [
                    "Phân tích mô tả",
                    "Phân tích chuẩn đoán",
                    "Phân tích dự đoán",
                    "Phân tích đề xuất"
                ],
                answer: "D",
                hint: "Phân tích đề xuất trả lời câu hỏi 'làm thế nào để nó xảy ra'."
            },
            {
                question: "Mục tiêu đúng nhất của phân tích dữ liệu lớn là gì ? (Câu 90)",
                options: [
                    "Biến dữ liệu thành thông tin chi tiết hữu ích",
                    "Sắp xếp dữ liệu có ích để sử dụng",
                    "Tạo ra các dữ liệu phù hợp nhất với hệ thống",
                    "Xây dựng hệ thống để quản lý dữ liệu lớn"
                ],
                answer: "A",
                hint: "Mục tiêu chính của phân tích dữ liệu lớn là trích xuất thông tin giá trị để hỗ trợ ra quyết định."
            },
            {
                question: "Hoạt động của Map Reduce bao gồm: (Câu 91)",
                options: [
                    "Trộn & sắp xếp - Map - Reduce",
                    "Map - Trộn & sắp xếp – Reduce",
                    "Reduce - Map - Trộn & sắp xếp",
                    "Sắp xếp - Trộn & Map – Reduce"
                ],
                answer: "B",
                hint: "Thứ tự hoạt động của MapReduce là Map (ánh xạ), Shuffle & Sort (trộn và sắp xếp), sau đó là Reduce (giảm)."
            },
            {
                question: "Phân tích chuẩn đoán sử dụng kỹ thuật nào ? (Câu 92)",
                options: [
                    "Lấy mẫu dữ liệu",
                    "Tương quan phân bổ",
                    "Thu tập dữ liệu",
                    "Khai phá dữ liệu"
                ],
                answer: "B",
                hint: "Phân tích chuẩn đoán thường sử dụng kỹ thuật tương quan phân bổ để tìm hiểu mối quan hệ giữa các biến."
            },
            {
                question: "Phân tích chuẩn đoán sử dụng kỹ thuật nào ? (Câu 93)",
                options: [
                    "Lấy mẫu mô tả",
                    "Tương quan phân bổ",
                    "Khôi phục dữ liệu",
                    "Thu tập dữ liệu"
                ],
                answer: "B",
                hint: "Tương quan phân bổ là một kỹ thuật được sử dụng trong phân tích chuẩn đoán."
            },
            {
                question: "Phân tích mô tả không phù hợp sử dụng để ? (Câu 94)",
                options: [
                    "Xây dựng các báo cáo",
                    "Lập bảng số liệu truyền thông",
                    "Mô hình hoá dữ liệu quá khứ",
                    "Phân tích tương quan"
                ],
                answer: "D",
                hint: "Phân tích mô tả tập trung vào việc mô tả dữ liệu đã có, ít dùng để phân tích tương quan sâu sắc."
            },
            {
                question: "Đâu là phân tích chuẩn đoán ? (Câu 95)",
                options: [
                    "Mô tả tương quan dữ liệu",
                    "Cung cấp cái nhinh sâu sắc về vấn đề",
                    "Phân tích sự bất thường từ dữ liệu lưu trữ",
                    "Mô hình hoá dữ liệu theo điều kiện"
                ],
                answer: "C",
                hint: "Phân tích chuẩn đoán thường bao gồm việc phân tích sự bất thường hoặc các vấn đề từ dữ liệu."
            },
            {
                question: "Trong MapReduce loại nào sau đây theo dõi quá trình tiêu thụ tài nguyên trên Cluster Node? (Câu 96)",
                options: [
                    "Name node",
                    "Master node",
                    "Single Master",
                    "Slave node"
                ],
                answer: "B",
                hint: "Master node (JobTracker) trong MapReduce chịu trách nhiệm theo dõi tài nguyên và tiến độ công việc."
            },
            {
                question: "Trong MapReduce loại nào sau đây thực thi các tác vụ và cung cấp thông tin trạng thai tác vụ? (Câu 97)",
                options: [
                    "Name node",
                    "Master node",
                    "Single Master",
                    "Slave node"
                ],
                answer: "D",
                hint: "Slave node (TaskTracker) thực thi các tác vụ và báo cáo trạng thái về Master."
            },
            {
                question: "Trong MapReduce loại nào sau đây được cung cấp task-status? (Câu 98)",
                options: [
                    "Name node",
                    "JobTracker",
                    "Single Master",
                    "Slave node"
                ],
                answer: "B",
                hint: "TaskTracker cung cấp task status cho JobTracker."
            },
            {
                question: "Mô hình MapReduce có thể chạy trên số lượng máy chủ? (Câu 99)",
                options: [
                    "Vài máy",
                    "Hàng nghìn máy",
                    "Hàng trăm máy",
                    "Một máy chủ Master"
                ],
                answer: "B",
                hint: "MapReduce được thiết kế để mở rộng trên hàng nghìn máy chủ."
            },
            {
                question: "Mô hình MapReduce thuộc lớp nào ? (Câu 100)",
                options: [
                    "Lớp lưu trữ dữ liệu",
                    "Lớp thu thập dữ liệu",
                    "Lớp xử lý dữ liệu",
                    "Lớp phân tích dữ liệu"
                ],
                answer: "C",
                hint: "MapReduce là một khung xử lý dữ liệu phân tán."
            },
            {
                question: "Lợi ích từ Phân tích dữ liệu lớn là ? (Câu 101)",
                options: [
                    "Tất cả",
                    "Ra quyết định nhanh hơn, tốt hơn",
                    "Giảm chi phí và tăng hiệu quả hoạt động",
                    "Cải tiến theo định hướng dữ liệu cho thị trường"
                ],
                answer: "A",
                hint: "Phân tích dữ liệu lớn mang lại nhiều lợi ích, bao gồm cải thiện quyết định, giảm chi phí và thúc đẩy đổi mới."
            },
            {
                question: "Các ứng dụng phân tích dữ liệu lớn cho Lĩnh vực bán lẻ (Câu 102)",
                options: [
                    "Dự đoán hành vi mua sắm của khách hàng",
                    "Xây dựng mô hình chi tiêu cho từng khách hàng",
                    "Phân tích hành trình của khách hàng",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Trong bán lẻ, Big Data giúp dự đoán hành vi, xây dựng hồ sơ khách hàng và phân tích hành trình mua sắm."
            },
            {
                question: "Ứng dụng phân tích dữ liệu lớn hỗ trợ ngành Y tế (Câu 103)",
                options: [
                    "Tăng việc khai thác tối ưu hoá máy móc",
                    "Tăng doanh thu từ phần mềm y tế",
                    "Tăng tỉnh chính xác của chẩn đoán",
                    "Tất cả"
                ],
                answer: "C",
                hint: "Trong y tế, Big Data đặc biệt giúp tăng độ chính xác trong chẩn đoán và điều trị."
            },
            {
                question: "Trong kiến trúc Apache Hadoop HDFS thuộc (Câu 104)",
                options: [
                    "Lớp lưu trữ",
                    "Lớp truyền tải",
                    "Lớp quản lý tài nguyên",
                    "Lớp xử lý dữ liệu"
                ],
                answer: "A",
                hint: "HDFS (Hadoop Distributed File System) là lớp lưu trữ dữ liệu của Hadoop."
            },
            {
                question: "Trong kiến trúc Apache Hadoop YARN là (Câu 105)",
                options: [
                    "Lớp lưu trữ",
                    "Lớp truyền tải",
                    "Lớp quản lý tài nguyên",
                    "Lớp xử lý dữ liệu"
                ],
                answer: "C",
                hint: "YARN (Yet Another Resource Negotiator) là lớp quản lý tài nguyên của Hadoop."
            },
            {
                question: "Trong kiến trúc Apache Hadoop MapReduce là (Câu 106)",
                options: [
                    "Lớp lưu trữ",
                    "Lớp truyền tải",
                    "Lớp quản lý tài nguyên",
                    "Lớp xử lý dữ liệu"
                ],
                answer: "D",
                hint: "MapReduce là một mô hình/lớp xử lý dữ liệu trong Hadoop."
            },
            {
                question: "Kiến trúc Hadoop hỗ trợ những ngôn ngữ nào (Câu 107)",
                options: [
                    "Java",
                    "Tất cả",
                    "C++",
                    "Python"
                ],
                answer: "B",
                hint: "Mặc dù Hadoop cốt lõi được viết bằng Java, nhưng nó hỗ trợ các API cho nhiều ngôn ngữ khác nhau."
            },
            {
                question: "Spark được Apache Software Foundation phát triển từ năm nào (Câu 108)",
                options: [
                    "1993",
                    "2013",
                    "2009",
                    "2007"
                ],
                answer: "C",
                hint: "Apache Spark được phát triển ban đầu tại UC Berkeley AMPLab vào năm 2009."
            },
            {
                question: "Apache Kafka là công cụ hỗ trợ ? (Câu 109)",
                options: [
                    "Xử lý phân tán",
                    "Lưu trữ phân tán",
                    "Hệ quản trị CSDL",
                    "Thu tập dữ liệu"
                ],
                answer: "D",
                hint: "Apache Kafka là một nền tảng streaming events, thường dùng để thu thập và truyền tải dữ liệu."
            },
            {
                question: "Apache Storm là công cụ hỗ trợ? (Câu 110)",
                options: [
                    "Xử lý phân tán",
                    "Lưu trữ phân tán",
                    "Phân tích dữ liệu",
                    "Thu tập dữ liệu"
                ],
                answer: "A",
                hint: "Apache Storm là một hệ thống xử lý phân tán theo thời gian thực."
            },
            {
                question: "Đâu không phải là chế độ hoạt động của Hadoop? (Câu 111)",
                options: [
                    "Chế độ phân phối giả",
                    "Chế độ phân phối toàn cầu",
                    "Chế độ độc lập",
                    "Chế độ phân phối hoàn toàn"
                ],
                answer: "B",
                hint: "Hadoop có các chế độ Standalone, Pseudo-distributed và Fully Distributed. Không có 'phân phối toàn cầu'."
            },
            {
                question: "Các tệp HDFS được thiết kế cho (Câu 112)",
                options: [
                    "Nhiều người viết và sửa đổi ở các hiệu số tùy ý.",
                    "Chỉ nối vào cuối tệp",
                    "Chỉ ghi thành tệp một lần.",
                    "Truy cập dữ liệu có độ trễ thấp."
                ],
                answer: "C",
                hint: "HDFS được tối ưu cho việc ghi một lần và đọc nhiều lần."
            },
            {
                question: "Tính năng định vị dữ liệu trong Hadoop có nghĩa là (Câu 113)",
                options: [
                    "Lưu trữ cùng một dữ liệu trên nhiều nút.",
                    "Chuyển vị trí dữ liệu từ nút này sang nút khác.",
                    "Đồng định vị dữ liệu với các nút tính toán.",
                    "Phân phối dữ liệu trên nhiều nút."
                ],
                answer: "C",
                hint: "Data locality là việc đặt tính toán gần dữ liệu để giảm di chuyển dữ liệu qua mạng."
            },
            {
                question: "Khó khăn khi đọc và ghi dữ liệu song song từ nhiều nguồn là gì? (Câu 114)",
                options: [
                    "Xử lý khối lượng lớn dữ liệu nhanh hơn.",
                    "Kết hợp dữ liệu từ nhiều nguồn.",
                    "Phần mềm cần thiết để thực hiện nhiệm vụ này là cực kỳ tốn kém.",
                    "Phần cứng cần thiết để thực hiện tác vụ này là cực kỳ tốn kém."
                ],
                answer: "B",
                hint: "Thách thức chính là việc tổng hợp và quản lý dữ liệu từ nhiều nguồn khác nhau."
            },
            {
                question: "So với RDBMS, Hadoop (Câu 115)",
                options: [
                    "Có tính toàn vẹn dữ liệu cao hơn.",
                    "Có giao dịch ACID không",
                    "Nó thích hợp để đọc và viết nhiều lần",
                    "Hoạt động tốt hơn trên dữ liệu phi cấu trúc và bán cấu trúc."
                ],
                answer: "D",
                hint: "Hadoop vượt trội trong việc xử lý dữ liệu phi cấu trúc và bán cấu trúc, không phải RDBMS."
            },
            {
                question: "Yếu tố giới hạn hiện tại đối với kích thước của một cụm hadoop là (Câu 116)",
                options: [
                    "Nhiệt lượng dư thừa tạo ra trong trung tâm dữ liệu",
                    "Giới hạn trên của băng thông mạng",
                    "Giới hạn trên của RAM trong NameNode",
                    "4000 datanode"
                ],
                answer: "C",
                hint: "NameNode lưu trữ metadata của HDFS trong RAM, nên RAM của NameNode là một yếu tố giới hạn kích thước cụm."
            },
            {
                question: "Trong HDFS, các tệp không thể (Câu 117)",
                options: [
                    "Đọc",
                    "Xoá",
                    "Thực thi",
                    "Lưu trữ"
                ],
                answer: "C",
                hint: "HDFS là hệ thống tệp phân tán, không phải hệ thống thực thi lệnh."
            },
            {
                question: "Điều nào sau đây không phải là mục tiêu của HDFS? (Câu 118)",
                options: [
                    "Phát hiện lỗi và khôi phục",
                    "Xử lý tập dữ liệu khổng lồ",
                    "Ngăn chặn việc xóa dữ liệu",
                    "Cung cấp băng thông mạng cao để di chuyển dữ liệu"
                ],
                answer: "C",
                hint: "HDFS không nhằm mục đích ngăn chặn việc xóa dữ liệu; nó tập trung vào khả năng chịu lỗi và xử lý dữ liệu lớn."
            },
            {
                question: "YARN là viết tắt của (Câu 119)",
                options: [
                    "Yahoo's another resource name",
                    "Yet another resource negotiator",
                    "Yahoo's archived Resource names",
                    "Yet another resource need."
                ],
                answer: "B",
                hint: "YARN là viết tắt của Yet Another Resource Negotiator."
            },
            {
                question: "Kiến trúc HDFS trong Hadoop có nguồn gốc là (Câu 120)",
                options: [
                    "Hệ thống tệp phân phối của Google",
                    "Hệ thống tệp phân tán của Yahoo",
                    "Hệ thống tệp phân tán của Facebook",
                    "Hệ thống tệp phân tán của Azure"
                ],
                answer: "A",
                hint: "HDFS được lấy cảm hứng từ Google File System (GFS)."
            },
            {
                question: "HDFS là viết tắt của (Câu 121)",
                options: [
                    "Hệ thống tệp phân tán cao. (Highly distributed file system.)",
                    "Hệ thống tệp được hướng dẫn Hadoop. (Hadoop directed file system)",
                    "Hệ tệp phân tán cao. (Highly distributed file shell)",
                    "Hệ thống tệp phân tán Hadoop. (Hadoop distributed file system)"
                ],
                answer: "D",
                hint: "HDFS là viết tắt của Hadoop Distributed File System."
            },
            {
                question: "Thành phân nào không thuộc Hadoop? (Câu 122)",
                options: [
                    "YARN",
                    "HDFS",
                    "MapReduce",
                    "GFS"
                ],
                answer: "D",
                hint: "GFS (Google File System) là tiền thân của HDFS, nhưng GFS không phải là một thành phần của Hadoop."
            },
            {
                question: "Thành phần chính của hệ thống Hadoop là ? (Câu 123)",
                options: [
                    "MapReduce",
                    "HDFS",
                    "YARN",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Các thành phần chính của Hadoop bao gồm HDFS (lưu trữ), YARN (quản lý tài nguyên) và MapReduce (xử lý)."
            },
            {
                question: "Apache Kafka là nền tảng mở được phát triển bởi ? (Câu 124)",
                options: [
                    "LinkedIn",
                    "Facebook",
                    "Google",
                    "IBM"
                ],
                answer: "A",
                hint: "Apache Kafka ban đầu được phát triển bởi LinkedIn."
            },
            {
                question: "Công cụ nào hỗ trợ tích hợp dữ liệu (Câu 125)",
                options: [
                    "Dell Boomi",
                    "Snaplogic",
                    "SAP Data Services",
                    "Tất cả"
                ],
                answer: "D",
                hint: "Dell Boomi, Snaplogic, và SAP Data Services đều là các công cụ tích hợp dữ liệu."
            }
        ];

        let currentQuestionIndex = 0; // Index in currentQuizOrder
        let questionStates = Array.from({ length: quizData.length }, () => ({
            userAnswer: null, // Index of selected option (0, 1, 2, 3)
            status: 'unanswered', // 'unanswered', 'correct', 'incorrect'
            isMarkedForReview: false // true if marked for review
        }));
        let shuffledOptions = []; // Stores shuffled options for current question display
        let currentQuizOrder = []; // Stores the shuffled order of original quizData indices
        let timerInterval;
        let timeLeft;
        let isTimerRunning = false;

        const questionNumberElem = document.getElementById('questionNumber');
        const questionTextElem = document.getElementById('questionText');
        const optionsContainerElem = document.getElementById('optionsContainer');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const checkAnswerBtn = document.getElementById('checkAnswerBtn');
        const shuffleAnswersToggle = document.getElementById('shuffleAnswers');
        const shuffleQuestionsOrderToggle = document.getElementById('shuffleQuestionsOrder');
        const studyModeToggle = document.getElementById('studyModeToggle');
        const markForReviewBtn = document.getElementById('markForReviewBtn'); // New button
        const questionNav = document.getElementById('questionNav');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const resetQuizBtn = document.getElementById('resetQuizBtn');
        const quizSummary = document.getElementById('quizSummary');
        const incorrectQuestionsList = document.getElementById('incorrectQuestionsList');
        const markedQuestionsList = document.getElementById('markedQuestionsList'); // New list for marked questions

        const timeLimitInput = document.getElementById('timeLimitInput');
        const timerDisplay = document.getElementById('timerDisplay');
        const startTimerBtn = document.getElementById('startTimerBtn');
        const pauseTimerBtn = document.getElementById('pauseTimerBtn');
        const resetTimerBtn = document.getElementById('resetTimerBtn');
        const progressBarFill = document.getElementById('progressBarFill');

        const messageBoxOverlay = document.getElementById('messageBoxOverlay');
        const messageBox = document.getElementById('messageBox');
        const messageBoxTitle = document.getElementById('messageBoxTitle');
        const messageBoxContent = document.getElementById('messageBoxContent');
        const messageBoxButton = document.getElementById('messageBoxButton');

        // Hàm hiển thị hộp thông báo tùy chỉnh
        function showMessageBox(title, content, onConfirm = null) {
            messageBoxTitle.textContent = title;
            messageBoxContent.textContent = content;
            messageBoxOverlay.style.display = 'block';
            messageBox.style.display = 'flex';
            pauseTimer(); // Pause timer when message box is open
            messageBoxButton.onclick = () => {
                messageBoxOverlay.style.display = 'none';
                messageBox.style.display = 'none';
                if (onConfirm) {
                    onConfirm();
                } else if (isTimerRunning) {
                    startTimer(); // Resume timer if it was running
                }
            };
        }

        // Hàm xáo trộn mảng (Fisher-Yates algorithm)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Hàm ánh xạ A, B, C, D sang chỉ số 0, 1, 2, 3
        function getOptionIndex(optionLetter) {
            return optionLetter.charCodeAt(0) - 'A'.charCodeAt(0);
        }

        // Hàm ánh xạ chỉ số 0, 1, 2, 3 sang A, B, C, D
        function getOptionLetter(optionIndex) {
            return String.fromCharCode('A'.charCodeAt(0) + optionIndex);
        }

        // Hàm khởi tạo thứ tự câu hỏi (xáo trộn hoặc tuần tự)
        function initializeQuizOrder() {
            if (shuffleQuestionsOrderToggle.checked) {
                currentQuizOrder = shuffleArray(Array.from({ length: quizData.length }, (_, i) => i));
            } else {
                currentQuizOrder = Array.from({ length: quizData.length }, (_, i) => i);
            }
        }

        // Hàm hiển thị câu hỏi hiện tại
        function displayQuestion() {
            const originalQuestionIndex = currentQuizOrder[currentQuestionIndex];
            const questionData = quizData[originalQuestionIndex];
            const questionState = questionStates[originalQuestionIndex];

            questionNumberElem.textContent = `Câu ${currentQuestionIndex + 1}/${quizData.length}`;
            questionTextElem.textContent = questionData.question;
            optionsContainerElem.innerHTML = '';

            // Tạo một bản sao của các lựa chọn để xáo trộn
            let optionsToDisplay = [...questionData.options];

            if (shuffleAnswersToggle.checked) {
                // Xáo trộn các lựa chọn, giữ originalIdx
                shuffledOptions = shuffleArray(optionsToDisplay.map((opt, idx) => ({ opt, originalIdx: idx })));
            } else {
                // Giữ nguyên thứ tự
                shuffledOptions = optionsToDisplay.map((opt, idx) => ({ opt, originalIdx: idx }));
            }

            const hasBeenChecked = questionState.status !== 'unanswered';
            const correctOptionIndex = getOptionIndex(questionData.answer);

            shuffledOptions.forEach((item, index) => {
                const optionButton = document.createElement('button');
                optionButton.classList.add('option-button', 'rounded-lg', 'focus:outline-none');
                optionButton.dataset.originalIndex = item.originalIdx; // Lưu trữ chỉ số gốc của đáp án
                optionButton.textContent = `${getOptionLetter(index)}. ${item.opt}`; // Hiển thị đáp án A, B, C, D theo thứ tự mới
                optionsContainerElem.appendChild(optionButton);

                if (hasBeenChecked || isTimerFinished()) { // If timer finished, disable all options
                    // Nếu câu hỏi đã được kiểm tra, vô hiệu hóa các lựa chọn
                    optionButton.classList.add('disabled');
                    optionButton.disabled = true;

                    // Đánh dấu đáp án đúng và bôi đậm
                    if (item.originalIdx === correctOptionIndex) {
                        optionButton.classList.add('correct');
                        optionButton.classList.remove('selected');
                        optionButton.innerHTML = `${getOptionLetter(index)}. <b>${item.opt}</b>`;
                    }
                    // Đánh dấu lựa chọn của người dùng (nếu có) và màu đỏ nếu sai
                    if (item.originalIdx === questionState.userAnswer) {
                        optionButton.classList.add('selected');
                        if (questionState.userAnswer !== correctOptionIndex) {
                            optionButton.classList.add('incorrect');
                        }
                    }
                } else {
                    // Nếu chưa kiểm tra, gắn sự kiện click
                    optionButton.addEventListener('click', () => selectOption(item.originalIdx, optionButton));
                    // Nếu người dùng đã chọn đáp án trước đó nhưng chưa kiểm tra, đánh dấu lại
                    if (questionState.userAnswer !== null && item.originalIdx === questionState.userAnswer) {
                        optionButton.classList.add('selected');
                    }
                }
            });

            updateNavigationButtons();
            updateQuestionNavButtons();
            updateMarkForReviewButton(); // Update mark for review button state
            updateProgressBar(); // Update progress bar
            quizSummary.classList.add('hidden'); // Hide summary when navigating questions
        }

        // Hàm chọn đáp án
        function selectOption(selectedIndex, clickedButton) {
            const originalQuestionIndex = currentQuizOrder[currentQuestionIndex];
            const questionState = questionStates[originalQuestionIndex];

            // Only allow selection if not already checked and timer is not finished
            if (questionState.status === 'unanswered' && !isTimerFinished()) {
                // Xóa lựa chọn cũ
                document.querySelectorAll('.option-button').forEach(btn => {
                    btn.classList.remove('selected');
                });

                // Đánh dấu lựa chọn mới
                clickedButton.classList.add('selected');
                questionState.userAnswer = selectedIndex; // Lưu trữ đáp án người dùng theo chỉ số gốc

                // Nếu đang ở chế độ học tập, kiểm tra đáp án ngay lập tức
                if (studyModeToggle.checked) {
                    checkAnswer();
                } else {
                    // Ngược lại, kích hoạt nút kiểm tra đáp án
                    checkAnswerBtn.disabled = false;
                }
            }
        }

        // Hàm kiểm tra đáp án
        function checkAnswer() {
            const originalQuestionIndex = currentQuizOrder[currentQuestionIndex];
            const questionData = quizData[originalQuestionIndex];
            const questionState = questionStates[originalQuestionIndex];

            if (questionState.userAnswer === null && !isTimerFinished()) {
                showMessageBox('Chưa chọn đáp án', 'Vui lòng chọn một đáp án trước khi kiểm tra.');
                return;
            }

            // Vô hiệu hóa tất cả các nút đáp án sau khi kiểm tra
            document.querySelectorAll('.option-button').forEach(btn => {
                btn.classList.add('disabled');
                btn.disabled = true;
            });

            const correctOptionIndex = getOptionIndex(questionData.answer);
            const userAnswerIndex = questionState.userAnswer;

            // Đánh dấu đáp án đúng/sai trên UI và bôi đậm đáp án đúng
            shuffledOptions.forEach((item, index) => {
                const optionButton = optionsContainerElem.children[index];
                if (item.originalIdx === correctOptionIndex) {
                    optionButton.classList.add('correct');
                    optionButton.classList.remove('selected'); // Đảm bảo đáp án đúng không bị ghi đè bởi "selected"
                    optionButton.innerHTML = `${getOptionLetter(index)}. <b>${item.opt}</b>`; // Bôi đậm đáp án đúng
                } else if (item.originalIdx === userAnswerIndex) {
                    optionButton.classList.add('incorrect');
                }
            });

            // Cập nhật trạng thái câu hỏi theo chỉ số gốc
            if (userAnswerIndex === correctOptionIndex) {
                questionState.status = 'correct';
            } else {
                questionState.status = 'incorrect';
            }

            // Vô hiệu hóa nút kiểm tra đáp án sau khi đã kiểm tra (nếu không ở chế độ học tập)
            if (!studyModeToggle.checked) {
                checkAnswerBtn.disabled = true;
            }

            updateQuestionNavButtons(); // Cập nhật màu sắc nút điều hướng
            updateNavigationButtons(); // Cập nhật trạng thái nút điều hướng (ẩn/hiện nút kiểm tra)
        }

        // Hàm cập nhật trạng thái các nút điều hướng
        function updateNavigationButtons() {
            prevBtn.disabled = currentQuestionIndex === 0;
            nextBtn.disabled = currentQuestionIndex === quizData.length - 1;

            const originalQuestionIndex = currentQuizOrder[currentQuestionIndex];
            const questionState = questionStates[originalQuestionIndex];
            const hasAnswered = questionState.userAnswer !== null;
            const hasBeenChecked = questionState.status !== 'unanswered';
            const timerFinished = isTimerFinished();

            // Ẩn hoặc hiển thị nút kiểm tra đáp án dựa trên chế độ học tập
            if (studyModeToggle.checked || timerFinished) {
                checkAnswerBtn.classList.add('hidden');
            } else {
                checkAnswerBtn.classList.remove('hidden');
                checkAnswerBtn.disabled = !hasAnswered || hasBeenChecked;
            }

            // Mark for Review button state
            markForReviewBtn.disabled = timerFinished;

            // Hiển thị nút Reset và tổng kết nếu tất cả câu hỏi đã được trả lời và kiểm tra hoặc hết giờ
            const allAnsweredOrChecked = questionStates.every(state => state.status !== 'unanswered');
            if ((currentQuestionIndex === quizData.length - 1 && allAnsweredOrChecked) || timerFinished) {
                resetQuizBtn.classList.remove('hidden');
                scoreDisplay.classList.remove('hidden');
                calculateScore();
                displayQuizSummary(); // Show summary
                pauseTimer(); // Ensure timer is paused at the end
            } else {
                resetQuizBtn.classList.add('hidden');
                scoreDisplay.classList.add('hidden');
                quizSummary.classList.add('hidden'); // Ensure summary is hidden
            }
        }

        // Hàm điều hướng câu hỏi
        function navigate(direction) {
            if (direction === 'prev' && currentQuestionIndex > 0) {
                currentQuestionIndex--;
            } else if (direction === 'next' && currentQuestionIndex < quizData.length - 1) {
                currentQuestionIndex++;
            }
            displayQuestion();
        }

        // Tạo các nút điều hướng câu hỏi (1, 2, 3...)
        function createQuestionNavigation() {
            questionNav.innerHTML = '';
            for (let i = 0; i < quizData.length; i++) {
                const button = document.createElement('button');
                button.classList.add('question-nav-button');
                button.textContent = i + 1; // Hiển thị số thứ tự gốc
                button.dataset.originalIndex = i; // Lưu trữ chỉ số gốc
                
                const displayIndex = currentQuizOrder.indexOf(i);
                
                if (displayIndex === currentQuestionIndex) {
                    button.classList.add('active');
                }
                button.addEventListener('click', () => {
                    currentQuestionIndex = displayIndex; // Chuyển đến vị trí hiển thị của câu hỏi đó
                    displayQuestion();
                });
                questionNav.appendChild(button);
            }
            updateQuestionNavButtons();
        }

        // Cập nhật màu sắc các nút điều hướng câu hỏi dựa trên trạng thái làm bài
        function updateQuestionNavButtons() {
            document.querySelectorAll('.question-nav-button').forEach(button => {
                button.classList.remove('active', 'answered-correctly', 'answered-incorrectly', 'marked-for-review');
                
                const originalIdx = parseInt(button.dataset.originalIndex);
                const questionState = questionStates[originalIdx];
                
                if (currentQuizOrder[currentQuestionIndex] === originalIdx) {
                    button.classList.add('active');
                }

                if (questionState.status === 'correct') {
                    button.classList.add('answered-correctly');
                } else if (questionState.status === 'incorrect') {
                    button.classList.add('answered-incorrectly');
                }

                if (questionState.isMarkedForReview) {
                    button.classList.add('marked-for-review');
                }
            });
        }

        // Tính điểm và hiển thị
        function calculateScore() {
            let correctCount = 0;
            for (let i = 0; i < quizData.length; i++) {
                const question = quizData[i];
                const questionState = questionStates[i];
                if (questionState.userAnswer !== null) {
                    const correctIndex = getOptionIndex(question.answer);
                    if (questionState.userAnswer === correctIndex) {
                        correctCount++;
                    }
                }
            }
            scoreDisplay.textContent = `Bạn đã trả lời đúng ${correctCount}/${quizData.length} câu.`;
        }

        // Hiển thị phần tổng kết các câu trả lời sai và câu đã đánh dấu
        function displayQuizSummary() {
            incorrectQuestionsList.innerHTML = '';
            markedQuestionsList.innerHTML = '';
            let hasIncorrectAnswers = false;
            let hasMarkedQuestions = false;

            // Iterate through original quizData indices for summary
            quizData.forEach((question, originalIdx) => {
                const questionState = questionStates[originalIdx];
                const correctOptionText = question.options[getOptionIndex(question.answer)];

                if (questionState.status === 'incorrect') {
                    hasIncorrectAnswers = true;
                    const itemDiv = document.createElement('div');
                    itemDiv.classList.add('incorrect-question-item');
                    itemDiv.innerHTML = `
                        <p class="question-text-summary">Câu ${originalIdx + 1}: ${question.question}</p>
                        <p>Đáp án đúng: <span class="correct-answer-summary"><b>${correctOptionText}</b></span></p>
                        <p class="hint-summary">Gợi ý: ${question.hint || 'Không có gợi ý cụ thể.'}</p>
                    `;
                    incorrectQuestionsList.appendChild(itemDiv);
                }
                if (questionState.isMarkedForReview) {
                    hasMarkedQuestions = true;
                    const itemDiv = document.createElement('div');
                    itemDiv.classList.add('marked-question-item');
                    itemDiv.innerHTML = `
                        <p class="question-text-summary">Câu ${originalIdx + 1}: ${question.question}</p>
                        <p>Đáp án đúng: <span class="correct-answer-summary"><b>${correctOptionText}</b></span></p>
                        <p class="hint-summary">Gợi ý: ${question.hint || 'Không có gợi ý cụ thể.'}</p>
                    `;
                    markedQuestionsList.appendChild(itemDiv);
                }
            });

            if (!hasIncorrectAnswers) {
                incorrectQuestionsList.innerHTML = '<p class="text-center text-green-700">Không có câu trả lời sai!</p>';
            }
            if (!hasMarkedQuestions) {
                markedQuestionsList.innerHTML = '<p class="text-center text-gray-500">Không có câu hỏi nào được đánh dấu để xem lại.</p>';
            }
            
            quizSummary.classList.remove('hidden');
        }

        // Hàm quản lý nút đánh dấu xem lại
        function updateMarkForReviewButton() {
            const originalQuestionIndex = currentQuizOrder[currentQuestionIndex];
            const questionState = questionStates[originalQuestionIndex];
            if (questionState.isMarkedForReview) {
                markForReviewBtn.textContent = 'Bỏ đánh dấu xem lại';
                markForReviewBtn.classList.add('bg-orange-500', 'hover:bg-orange-600');
                markForReviewBtn.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
            } else {
                markForReviewBtn.textContent = 'Đánh dấu xem lại';
                markForReviewBtn.classList.remove('bg-orange-500', 'hover:bg-orange-600');
                markForReviewBtn.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
            }
        }

        // Hàm chuyển đổi trạng thái đánh dấu xem lại
        function toggleMarkForReview() {
            const originalQuestionIndex = currentQuizOrder[currentQuestionIndex];
            questionStates[originalQuestionIndex].isMarkedForReview = !questionStates[originalQuestionIndex].isMarkedForReview;
            updateMarkForReviewButton();
            updateQuestionNavButtons(); // Update nav button color
        }

        // Timer functions
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
        }

        function updateTimerDisplay() {
            timerDisplay.textContent = formatTime(timeLeft);
            if (timeLeft <= 0) {
                endQuizByTimer();
            }
        }

        function startTimer() {
            if (isTimerRunning) return;
            isTimerRunning = true;
            startTimerBtn.disabled = true;
            pauseTimerBtn.disabled = false;
            timeLimitInput.disabled = true; // Disable input when timer starts
            timerInterval = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();
            }, 1000);
        }

        function pauseTimer() {
            if (!isTimerRunning) return;
            isTimerRunning = false;
            clearInterval(timerInterval);
            startTimerBtn.disabled = false;
            pauseTimerBtn.disabled = true;
        }

        function resetTimer() {
            pauseTimer();
            const minutes = parseInt(timeLimitInput.value);
            timeLeft = minutes * 60;
            updateTimerDisplay();
            startTimerBtn.disabled = false;
            pauseTimerBtn.disabled = true;
            timeLimitInput.disabled = false; // Re-enable input
        }

        function endQuizByTimer() {
            pauseTimer();
            showMessageBox(
                'Hết giờ!',
                'Thời gian làm bài đã kết thúc. Bài thi sẽ được tổng kết.',
                () => {
                    // Check all unanswered questions as incorrect at the end of timer
                    questionStates.forEach((state, originalIdx) => {
                        if (state.status === 'unanswered') {
                            state.status = 'incorrect';
                            // No user answer means it's wrong, but don't set userAnswer to a value
                            // unless we want to show a specific wrong choice. For now, null is fine.
                        }
                    });
                    currentQuestionIndex = quizData.length - 1; // Move to last question to trigger summary
                    displayQuestion(); // Re-render last question with checked state
                    // The updateNavigationButtons will handle showing summary
                }
            );
        }

        function isTimerFinished() {
            return timeLeft <= 0 && !isTimerRunning;
        }

        function updateProgressBar() {
            const progress = (currentQuestionIndex + 1) / quizData.length * 100;
            progressBarFill.style.width = `${progress}%`;
        }

        // Reset bài thi
        function resetQuiz() {
            showMessageBox(
                'Xác nhận làm lại bài thi',
                'Bạn có chắc chắn muốn làm lại toàn bộ bài thi? Tất cả câu trả lời và thời gian sẽ bị xóa.',
                () => {
                    questionStates = Array.from({ length: quizData.length }, () => ({
                        userAnswer: null,
                        status: 'unanswered',
                        isMarkedForReview: false
                    }));
                    currentQuestionIndex = 0;
                    initializeQuizOrder();
                    displayQuestion();
                    createQuestionNavigation();
                    scoreDisplay.classList.add('hidden');
                    resetQuizBtn.classList.add('hidden');
                    quizSummary.classList.add('hidden');
                    incorrectQuestionsList.innerHTML = '';
                    markedQuestionsList.innerHTML = '';
                    if (!studyModeToggle.checked) {
                        checkAnswerBtn.disabled = true;
                        checkAnswerBtn.classList.remove('hidden');
                    }
                    resetTimer(); // Reset timer as part of quiz reset
                    updateProgressBar(); // Reset progress bar
                }
            );
        }

        // Event Listeners
        prevBtn.addEventListener('click', () => navigate('prev'));
        nextBtn.addEventListener('click', () => navigate('next'));
        checkAnswerBtn.addEventListener('click', checkAnswer);
        markForReviewBtn.addEventListener('click', toggleMarkForReview); // New event listener

        shuffleAnswersToggle.addEventListener('change', displayQuestion);
        shuffleQuestionsOrderToggle.addEventListener('change', resetQuiz); // Reset quiz to apply new question order
        studyModeToggle.addEventListener('change', () => {
            updateNavigationButtons();
            displayQuestion();
        });

        resetQuizBtn.addEventListener('click', resetQuiz);

        // Timer Event Listeners
        startTimerBtn.addEventListener('click', startTimer);
        pauseTimerBtn.addEventListener('click', pauseTimer);
        resetTimerBtn.addEventListener('click', resetTimer);
        timeLimitInput.addEventListener('change', resetTimer); // Reset timer if time limit changes

        // Keyboard Navigation
        document.addEventListener('keydown', (e) => {
            if (messageBoxOverlay.style.display === 'block') { // Do not allow keyboard navigation if message box is open
                return;
            }

            const currentQuestionState = questionStates[currentQuizOrder[currentQuestionIndex]];
            const hasBeenChecked = currentQuestionState.status !== 'unanswered';
            const hasAnswered = currentQuestionState.userAnswer !== null;

            switch (e.key) {
                case 'ArrowLeft':
                    navigate('prev');
                    break;
                case 'ArrowRight':
                    navigate('next');
                    break;
                case '1':
                case '2':
                case '3':
                case '4':
                    if (!hasBeenChecked && !isTimerFinished()) {
                        const optionButtons = optionsContainerElem.querySelectorAll('.option-button');
                        if (optionButtons[parseInt(e.key) - 1]) {
                            optionButtons[parseInt(e.key) - 1].click();
                        }
                    }
                    break;
                case 'a':
                case 'A':
                case 'b':
                case 'B':
                case 'c':
                case 'C':
                case 'd':
                case 'D':
                     if (!hasBeenChecked && !isTimerFinished()) {
                        const optionIndex = e.key.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0);
                        const optionButtons = optionsContainerElem.querySelectorAll('.option-button');
                        if (optionButtons[optionIndex]) {
                            optionButtons[optionIndex].click();
                        }
                    }
                    break;
                case 'Enter':
                    if (studyModeToggle.checked && hasAnswered && !hasBeenChecked && !isTimerFinished()) {
                        checkAnswer();
                    } else if (!studyModeToggle.checked && !checkAnswerBtn.disabled) {
                        checkAnswer();
                    } else if (nextBtn.disabled === false && hasBeenChecked) { // If checked and can go next
                        navigate('next');
                    }
                    break;
            }
        });


        // Khởi tạo bài thi khi tải trang
        window.onload = () => {
            initializeQuizOrder(); // Khởi tạo thứ tự câu hỏi ban đầu
            createQuestionNavigation();
            resetTimer(); // Initialize timer
            displayQuestion();
        };

    </script>
</body>
</html>
